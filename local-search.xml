<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>经济发展和资本增长的规律</title>
    <link href="/2024/06/22/%E7%BB%8F%E6%B5%8E%E5%8F%91%E5%B1%95%E5%92%8C%E8%B5%84%E6%9C%AC%E5%A2%9E%E9%95%BF%E7%9A%84%E8%A7%84%E5%BE%8B/"/>
    <url>/2024/06/22/%E7%BB%8F%E6%B5%8E%E5%8F%91%E5%B1%95%E5%92%8C%E8%B5%84%E6%9C%AC%E5%A2%9E%E9%95%BF%E7%9A%84%E8%A7%84%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>基于马克思主义和客观规律，对于经济发展和增长规律的简单总结</p><p>政府的中央银行（铸币权和其所有者）可以通过放出贷款或加息，向市场注入资金，以满足经济运行所需的货币，或以此刺激消费，推动经济增长。</p><blockquote><p>在现代银行业出现之前，钱庄是不会给储蓄者利息的，反而还会收取手续费。因为钱庄的投资手段匮乏，即使有了纸币，其金融能力也很有限。在全球化之前，社会团体之间的交流都非常有限，基本上都是以物易物，根本没有汇率的概念，即使到了二战之后，一段时间内，世界各国还是将黄金作为国际交易结算货币使用。</p></blockquote><p>那么，在没有政府投资手段的古典经济时代，市场是如何增长的呢？</p><p>市场就是商品交换的总和，如果没有政府发行的信用货币，那么在工业革命前金本位市场环境下，一切经济的增长来自于商品和劳动力这样的实际生产要素的增长。在古典经济时代，而无论是金银，农作物，矿物还是服务，都依赖于人口，要想增加商品的产出，必须要依赖于人口的增长。劳动力和资源的投入直接转化为生产力的提升，而经济增长受限于这些实际资源的限制。在新航路开辟和地理大发现之后，银行和保险业的诞生与发展，又推动了对于新大陆人口和资源的掠夺，资本迅速积累，为工业革命奠定基础。</p><p>工业革命通过机械化和专业化生产极大地提高了生产效率，促进了前所未有地经济增长。但是，在工业革命带来的经济繁荣增长，生活水平不断提高的表象下，严重依赖于金本位银本位的经济体制。金本位制度下货币供应量地刚性限制了经济地灵活性，导致金融体系脆弱，埋下了金融危机的种子。</p><p>一战总体而言是后起的帝国主义国家与旧的具有海上霸权的帝国主义国家之间的矛盾，并最终以一场大流感和沙俄帝国的崩溃而告终。一战后旧大陆的帝国主义国家为了偿还战争期间的债务，财政收入降低，对殖民地的掌控力因此严重下降，并且使美国和迎来了发展机遇，成为债权国和资本输出国，日本也在此期间发展成为海上强国。英法主导的分赃会仅仅只是重新瓜分了殖民地利益的划分，却没有对根本矛盾做出任何帮助。20年后，英法等国不仅没有从经济衰退中走出来，英国更是绥靖政策放纵德国扩张，最终导致二战爆发。二战过后，战胜国在又一次的分赃大会上，利用战争期间催生的新技术，新秩序，宣布形成了布雷顿森林体系。通过直接将美元和黄金挂钩，各国不再需要通过严格的货币政策控制货币流通，因金银外流导致的通货紧缩也不再容易发生。现代信用货币体系基本宣告诞生。二战后的独立运动浪潮，其实更多的还是帝国主义国家对于在殖民地的利益和责任的主动切割。在殖民地的资本已经足够强大，能够掌控当地的经济命脉，为什么还要承担当地政府分配利益的责任呢？虽然丧失了一部分利益，但是缩减的支出能够让老牌帝国主义国家尽快还上战争期间欠下贷款，这就足够了。</p><blockquote><p>银行会更愿意向信用良好的还款人借贷，信用良好分为两方面</p><blockquote><p>还款能力，还款人收入债务比（利润率）越高，还款人还款能力也就越高。也即他所剥削的剩余价值越高，生产技术越先进。<br>抵押物即还款人拥有的机械，矿场，土地和水域等自然资源，或他所拥有的股份，金融资产等可出售的有价值资产。</p></blockquote></blockquote><p> 冷战结束以来，尤其是在经历过互联网技术的繁荣发展后，生产力的增长速度逐渐放缓。新的技术在普及，也创造了一批新的增长，例如锂电池技术，光伏发电等。但这些新技术的投入使用过程中，也大量采用了新的生产方式，即采用更多大机械的生产，并且自动化程度提高，这虽然创造了一批更高工作报酬的工程师和技术人员岗位，但是企业所有者往往也获得更高的利润。虽然穷人的生活水平在不断提高，但是和富人之间的差距也在不断拉大，分配不均的矛盾也更大。</p><p>新技术的诞生催生了新的工作岗位，新的产业链，供应链，但是这些新技术相比于20世纪，却并没有提高社会大多数的消费。资本除了剥削剩余价值外，还总是积极的从所有劳动者手中抢走所有的资本。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么说赛博朋克绝对不会在现实中上演</title>
    <link href="/2024/06/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B%E7%BB%9D%E5%AF%B9%E4%B8%8D%E4%BC%9A%E5%9C%A8%E7%8E%B0%E5%AE%9E%E4%B8%AD%E4%B8%8A%E6%BC%94/"/>
    <url>/2024/06/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B%E7%BB%9D%E5%AF%B9%E4%B8%8D%E4%BC%9A%E5%9C%A8%E7%8E%B0%E5%AE%9E%E4%B8%AD%E4%B8%8A%E6%BC%94/</url>
    
    <content type="html"><![CDATA[<h2 id="批判赛博朋克"><a href="#批判赛博朋克" class="headerlink" title="批判赛博朋克"></a>批判赛博朋克</h2><ul><li>资本主义在完成了控制论革命，完全将人类劳动力从生产中剥离出去(通过出让微小的一部分利益让底层相对过剩人口不再反抗，并摧毁政府机关)后，资本家们确实可以完全依赖自动化机械过上完全自由的生活了。</li><li>政府并不是人民创造出来解决社会矛盾的，政府本身是社会矛盾无法调和的产物，它并不具备调和社会矛盾的能力，它其实是既得利益者掌握的防止受压迫者反抗体制摧毁体制的工具。</li></ul><blockquote><p><strong>可变资本</strong>指的是资本家用于购买劳动力的那一部分资本。劳动力在使用过程中，不仅能够创造出补偿劳动力价值的价值，而且能创造出剩余价值，使资本增值。这个剩余价值本身是可变化的，从而转化为劳动力的那部分资本在生产过程中改变自己的价值量，马克思称之为可变资本。资产阶级经济学家只承认<strong>固定资本</strong>和<strong>流动资本</strong>的划分，而不承认不变资本和可变资本的划分。</p><blockquote><p><strong>固定资本</strong>是指以厂房、机器、设备和工具等劳动资料的形式存在的生产资本，是流动资本的对称。它的物质形态全部参加生产过程，虽然受到磨损，但仍然长期保持固定的物质形态。它的价值不是一次全部转移，而是在生产过程中随着磨损一部分一部分地转移到新产品中去。<br><strong>不变资本</strong>是指在剩余价值生产过程中资本家用于购买生产资料的那一部分资本（用字母C表示），即以生产资料形态存在的资本，经过生产过程，它的价值随着物质形态的改变，转移到新产品中去，没有发生任何价值量的变化，价值不会增值。<br>固定资本分析物质的转变和损耗，而不变资本只考虑抽象的价值</p></blockquote></blockquote><ul><li>技术的进步会导致可变资本中用于购买劳动力的那部分资本因劳动力需求下降而下降。由于可变资本不断萎缩，底层民众中会产生大量超过资本雇佣能力的相对过剩人口。而相对过剩人口的增长，又会进一步降低劳资博弈中劳方的谈判力量。</li><li>马克思认为最终会爆发大规模的无产阶级大革命。并且在革命后，生产资料公有制会取代滋养这一切罪恶的私有制经济。然而事实是，发达资本国家的资本收买了本国底层民众，第三世界国家的无产阶级革命者最多只是实现了民族独立，却没能实现全世界无产阶级大团结。</li><li>在马克思主义理论中，无产阶级之所以能够接管世界，是因为无产阶级能够通过阶级革命炸毁生产资料私有制，解决资本主义秩序下周期性的经济危机。<ul><li>无产阶级因具有创造先进生产力的革命性才必然取代资产阶级主导社会生产。</li></ul></li><li>而现实中先进的发达国家通过转嫁矛盾，在凯恩斯主义和新自由主义之间灵活切换，不但度过了一次又一次周期性经济危机，缓和了国内社会矛盾，还挑拨了各国共产者之间的关系。</li><li>人工智能自动化技术的发展和资本的跨国自由流动，在当下都是必然的趋势，但赛博朋克也不可能真的在现实中上演。</li><li>之所以人尤其是无产者必须主动异化这一本质，是因为统治阶级有着指挥社会生产强迫无产者服从社会分工的权力，而之所以统治阶级拥有这种权力或者说之所以必然分裂出执掌权力的统治阶级和服从权力的被统治阶级，是因为人类社会需要组织起生产关系以实现物质的持续再生产。</li><li>当自动化技术满足了脱离人的物质再生产时，也就是生产关系被彻底颠覆之时，也就是分裂为统治与被统治阶级的人类社会阶级结构彻底扬弃之时，也就是人尤其是无产者服从于社会分工的异化本质被打破之时，也就是描述阶级社会的历史唯物主义终结之时。</li><li>自动化技术将终结历史唯物主义，生产力和生产力的矛盾将就此统一。</li><li>自动化技术非但不可能创造一个赛博宇宙，反倒恰是将哪些赛博宇宙中那些精英给吊死在路灯上的最后一根绳！</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>西方经济学的本色就是删除了殖民掠夺历史后，倒果为因的自圆其说</title>
    <link href="/2024/06/22/%E8%A5%BF%E6%96%B9%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%9C%AC%E8%89%B2%E5%B0%B1%E6%98%AF%E5%88%A0%E9%99%A4%E4%BA%86%E6%AE%96%E6%B0%91%E6%8E%A0%E5%A4%BA%E5%8E%86%E5%8F%B2%E5%90%8E%EF%BC%8C%E5%80%92%E6%9E%9C%E4%B8%BA%E5%9B%A0%E7%9A%84%E8%87%AA%E5%9C%86%E5%85%B6%E8%AF%B4/"/>
    <url>/2024/06/22/%E8%A5%BF%E6%96%B9%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%9C%AC%E8%89%B2%E5%B0%B1%E6%98%AF%E5%88%A0%E9%99%A4%E4%BA%86%E6%AE%96%E6%B0%91%E6%8E%A0%E5%A4%BA%E5%8E%86%E5%8F%B2%E5%90%8E%EF%BC%8C%E5%80%92%E6%9E%9C%E4%B8%BA%E5%9B%A0%E7%9A%84%E8%87%AA%E5%9C%86%E5%85%B6%E8%AF%B4/</url>
    
    <content type="html"><![CDATA[<p>这种观点反映了部分批评者对于西方经济学传统叙事的质疑，认为其在构建理论体系和分析经济发展模式时，往往忽视了历史上殖民掠夺对全球经济格局形成的深远影响。以下几点可以帮助理解这一批评的具体含义：</p><ol><li><strong>历史背景的忽略</strong>：批评者指出，西方经济学在探讨现代经济体系的起源和发展时，往往侧重于市场机制、技术创新、产权制度等因素，而较少系统性地纳入殖民时期资源掠夺、劳动力剥削、市场强占等历史事实。这些活动为欧洲国家积累了巨额财富，加速了工业化进程，构成了其后续经济发展的初始资本积累。</li><li><strong>因果关系的颠倒</strong>：有观点认为，西方经济学理论有时给人一种印象，即发达国家的繁荣主要是由于其内在的经济体制优越和创新能力，而忽略了这些国家早期通过殖民活动获得的不公平优势。这种论述方式被批评为“倒果为因”，因为它没有充分认识到殖民历史在塑造当前世界经济不平等中的作用。</li><li><strong>发展路径的单一叙事</strong>：西方经济学常推广一套适用于所有国家的经济发展模型，如自由市场、自由贸易等原则，却未充分考虑到不同国家历史起点的差异，尤其是殖民历史对后发国家经济结构和社会形态的深刻影响。这种“一刀切”的发展模式忽视了历史遗留问题的复杂性。</li><li><strong>理论与历史的脱节</strong>：批评者呼吁经济学研究应更加注重历史背景，将殖民掠夺等历史事件作为分析现代经济结构和国际分工的重要维度，以提供一个更为全面和真实的世界经济图景。</li></ol><p>总之，这一批评强调了在探讨经济理论和实践时，必须将历史的复杂性，特别是殖民历史的影响，纳入考量，以避免过于简化且可能具有误导性的理论构建。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>马克思主义科学方法论</title>
    <link href="/2024/06/22/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E7%A7%91%E5%AD%A6%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <url>/2024/06/22/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E7%A7%91%E5%AD%A6%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>马克思主义科学方法论根植于马克思主义哲学之中，特别是其唯物辩证法，这是一种根本性的哲学视角和分析工具，用于理解和改变世界。以下是其核心要点：</p><ol><li><strong>唯物主义基础</strong>：马克思主义方法论首先建立在唯物主义的基础之上，认为物质现实是第一性的，意识是第二性的，即物质存在决定意识，而非相反。这意味着在分析任何社会或自然现象时，首先要考虑物质条件和经济基础。</li><li><strong>辩证法</strong>：马克思主义吸收并改造了黑格尔的辩证法，将其从唯心主义转变为唯物主义辩证法。辩证法强调事物内部矛盾是推动事物发展的动力，事物在对立统一中不断发展变化。这要求观察问题时考虑事物的多面性、过程性和相互联系性。</li><li><strong>历史唯物主义</strong>：这是马克思主义方法论的一个独特贡献，认为社会存在决定社会意识，生产力的发展是社会变迁的根本原因。历史的推动力在于阶级斗争，以及生产关系与生产力之间的矛盾运动。</li><li><strong>实践原则</strong>：马克思主义强调理论与实践的统一，认为理论来源于实践，并应服务于实践。真理的标准在于实践的成功与否，主张一切从实际出发，实事求是。</li><li><strong>全面性与历史性</strong>：分析问题时，要求全面考察事物的各种因素及其历史发展过程，避免片面性和静止的观点。</li><li><strong>科学社会主义</strong>：基于对资本主义社会矛盾的分析，提出社会主义革命和建设的理论，旨在实现无产阶级的解放和全人类的自由全面发展。</li></ol><p>综上所述，马克思主义科学方法论是一种综合的分析框架，它指导我们以科学的态度和方法研究社会与自然，强调理论与实践相结合，动态地、矛盾地看待事物的发展，追求社会公正与人的解放。</p><p>马克思主义科学方法与传统分析方法相比，主要在以下几个方面展现出显著差异：</p><ol><li><p><strong>分析视角的转变</strong>：</p><ul><li><strong>传统分析</strong>往往侧重于表面现象的描述或道德、伦理的评判，有时会基于先验的哲学观念或抽象的原则来解释社会现象，比如强调个人品德、道德规范或君权神授等观念。</li><li><strong>马克思主义科学方法</strong>则强调从物质生产条件出发，关注经济基础如何决定上层建筑（包括政治制度、法律、文化等），以及社会生产力与生产关系之间的矛盾运动如何推动社会发展。这种方法更注重社会现象背后的经济和社会结构因素。</li></ul></li><li><p><strong>历史唯物主义的运用</strong>：</p><ul><li>传统分析可能更多依赖于历史事件的线性叙述或英雄人物的影响力来解释历史变迁。</li><li>马克思主义分析则运用历史唯物主义，认为历史的发展有其客观规律，是生产力与生产关系、经济基础与上层建筑之间矛盾运动的结果，从而提供了一种动态的历史观。</li></ul></li><li><p><strong>辩证法的引入</strong>：</p><ul><li>传统分析可能倾向于静态地看待事物，或者采用简单的因果逻辑。</li><li>马克思主义的唯物辩证法则强调事物内部的矛盾及其发展变化，认为一切事物都是在不断运动、变化和发展中的，这促进了对复杂社会现象的深入理解和多维度分析。</li></ul></li><li><p><strong>实践导向</strong>：</p><ul><li>传统分析可能偏向于理论抽象或纯粹的知识积累。</li><li>马克思主义方法则强调理论与实践的统一，认为理论必须来源于实践，并服务于实践，主张通过革命性的实践来改造社会。</li></ul></li></ol><p>以《中国官僚政治研究》为例，王亚南运用马克思主义方法，不是简单地批评官僚的腐败和个人道德问题，而是从社会经济结构出发，分析官僚政治产生的根本原因及其实质，从而超越了对个别现象的道德谴责，达到了对整个社会制度的深刻批判和理解。这种方法论的差异，使马克思主义分析能够触及问题的本质，提出更加根本的解决方案，而不仅仅是表面上的修修补补。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小镇面包店模型，发币机制</title>
    <link href="/2024/06/22/%E5%B0%8F%E9%95%87%E9%9D%A2%E5%8C%85%E5%BA%97%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%8F%91%E5%B8%81%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/06/22/%E5%B0%8F%E9%95%87%E9%9D%A2%E5%8C%85%E5%BA%97%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%8F%91%E5%B8%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="中央银行货币发行机制"><a href="#中央银行货币发行机制" class="headerlink" title="中央银行货币发行机制"></a>中央银行货币发行机制</h2><p>为应对潜在的通货紧缩，中央银行采取一系列措施增加货币供应：</p><ul><li><strong>购买国债</strong>：向政府购买国债，新发行货币作为支付方式，政府则利用这些货币支付公共支出，使货币进入流通。</li><li><strong>向商业银行提供贷款</strong>：通过再贴现、再贷款等手段，向商业银行注入新货币，银行再以贷款形式将资金传递给企业和个人。</li><li><strong>公开市场操作</strong>：直接购入政府债券或企业债券，向市场投放货币，增加银行体系的准备金，鼓励贷款，进一步提升货币供给。</li></ul><h2 id="市场的成员：个人，企业，商业银行，中央银行，政府。"><a href="#市场的成员：个人，企业，商业银行，中央银行，政府。" class="headerlink" title="市场的成员：个人，企业，商业银行，中央银行，政府。"></a>市场的成员：个人，企业，商业银行，中央银行，政府。</h2><h3 id="微观经济学："><a href="#微观经济学：" class="headerlink" title="微观经济学："></a>微观经济学：</h3><p>个人消费者和企业：主要在微观经济学中研究。个人消费者的行为涉及消费选择、预算约束、效用最大化等；企业则关注生产成本、产量决策、利润最大化以及市场竞争策略。<br>商业银行：在微观经济学中，商业银行的行为可被分析为如何根据利率、信用风险等因素决定贷款和存款政策，以及如何追求利润最大化。商业银行在资金的供需匹配中扮演关键角色，这也属于微观层面的分析。</p><h3 id="宏观经济学："><a href="#宏观经济学：" class="headerlink" title="宏观经济学："></a>宏观经济学：</h3><p>中央银行：主要在宏观经济学中分析，因为它负责制定和实施货币政策，如调节货币供应量、设定基准利率等，以影响整体经济的货币条件、控制通货膨胀、促进经济稳定与增长。<br>政府：同样在宏观经济学中占有重要位置，政府的财政政策（如税收、支出、预算赤字）对总需求、就业、经济增长有直接影响，同时也是宏观经济调控的关键工具之一。</p><h2 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h2><h3 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h3><ol><li><strong>货币供应过多</strong>：政府过度发行货币或银行信贷扩张过快，超出经济实际需求。</li><li><strong>需求拉动</strong>：总需求超过总供给，如经济过热，消费和投资旺盛。</li><li><strong>成本推进</strong>：原材料价格上涨、工资成本上升导致生产成本提高，传导至最终商品和服务价格。</li><li><strong>预期因素</strong>：公众对未来物价上涨的预期促使提前消费和投资，进一步推高物价。</li></ol><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><ul><li><strong>个人</strong>：购买力下降，储蓄缩水，生活成本增加。</li><li><strong>企业</strong>：短期内利润可能增加，但长期面临成本上升，消费者购买力下降。</li><li><strong>商业银行</strong>：贷款利率上升，贷款需求减少，但存款增加，利差可能扩大。</li><li><strong>央行</strong>：可能采取加息政策，减少货币供应，控制通胀。</li><li><strong>政府</strong>：税收名义值增加，但实际购买力可能下降，公共支出成本上升。</li></ul><h3 id="应对方式"><a href="#应对方式" class="headerlink" title="应对方式"></a>应对方式</h3><ul><li><strong>个人</strong>：投资抗通胀资产，如股票、房产。</li><li><strong>企业</strong>：提高效率，降低成本，调整定价策略。</li><li><strong>商业银行</strong>：调整贷款结构，增加对优质项目的贷款。</li><li><strong>央行</strong>：提高基准利率，出售政府债券吸收流动性。</li><li><strong>政府</strong>：财政紧缩，减少赤字，优化支出结构。</li></ul><h3 id="未能及时处理通货膨胀的后果："><a href="#未能及时处理通货膨胀的后果：" class="headerlink" title="未能及时处理通货膨胀的后果："></a>未能及时处理通货膨胀的后果：</h3><h4 id="个人："><a href="#个人：" class="headerlink" title="个人："></a>个人：</h4><ul><li><strong>购买力下降</strong>：随着物价上涨，相同金额的货币购买的商品和服务减少，生活成本增加。</li><li><strong>储蓄缩水</strong>：储蓄和固定收入的价值相对降低，个人财富减少。</li><li><strong>投资决策扭曲</strong>：高通胀环境下，人们倾向于投资实物资产以保值，而非基于长期价值判断。</li></ul><h4 id="企业："><a href="#企业：" class="headerlink" title="企业："></a>企业：</h4><ul><li><strong>成本上升</strong>：原材料和劳动力成本增加，压缩利润空间。</li><li><strong>定价策略复杂化</strong>：需要频繁调整价格以反映成本变动，可能损害客户关系。</li><li><strong>投资犹豫</strong>：未来不确定性增加，企业可能推迟扩张和长期投资计划。</li></ul><h4 id="商业银行："><a href="#商业银行：" class="headerlink" title="商业银行："></a>商业银行：</h4><ul><li><strong>信贷风险增加</strong>：借款人实际偿还能力随收入购买力下降而降低。</li><li><strong>资产质量下降</strong>：抵押品价值可能因通胀而被高估，增加银行风险。</li><li><strong>利率管理挑战</strong>：需平衡借贷成本与收益，避免不良贷款上升。</li></ul><h4 id="央行："><a href="#央行：" class="headerlink" title="央行："></a>央行：</h4><ul><li><strong>政策有效性降低</strong>：长期高通胀可能导致货币政策工具如利率调整效果减弱。</li><li><strong>货币信誉受损</strong>：持续通胀可能削弱货币的国际地位和国内信任度。</li><li><strong>经济调控复杂化</strong>：需要综合运用多种政策工具来遏制通胀，操作难度加大。</li></ul><h4 id="政府："><a href="#政府：" class="headerlink" title="政府："></a>政府：</h4><ul><li><strong>财政压力</strong>：通胀推高公共开支，同时税收收入的实际购买力下降。</li><li><strong>社会不满</strong>：民众生活水平下降，可能导致社会不稳定和政府信任度降低。</li><li><strong>资源配置扭曲</strong>：价格信号失真，不利于经济资源的有效配置。</li></ul><h2 id="通货紧缩"><a href="#通货紧缩" class="headerlink" title="通货紧缩"></a>通货紧缩</h2><h3 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h3><ol><li><strong>货币供应不足</strong>：银行信贷收缩，货币流通速度减慢。</li><li><strong>需求不足</strong>：经济衰退，消费者和企业信心下降，减少支出。</li><li><strong>产能过剩</strong>：供过于求，竞争激烈导致价格下跌。</li><li><strong>预期因素</strong>：预期未来价格更低，推迟消费和投资。</li></ol><h3 id="影响-1"><a href="#影响-1" class="headerlink" title="影响"></a>影响</h3><ul><li><strong>个人</strong>：虽短期内购买力提升，但长期可能面临失业风险，收入减少。</li><li><strong>企业</strong>：销售额下滑，利润减少，库存积压，投资意愿低。</li><li><strong>商业银行</strong>：贷款违约风险增加，信贷收缩，盈利困难。</li><li><strong>央行</strong>：可能降息，增加货币供应，刺激信贷和消费。</li><li><strong>政府</strong>：税收减少，财政收入下降，公共支出压力增大。</li></ul><h3 id="应对方式-1"><a href="#应对方式-1" class="headerlink" title="应对方式"></a>应对方式</h3><ul><li><strong>个人</strong>：增加储蓄，谨慎投资，减少负债。</li><li><strong>企业</strong>：创新和差异化竞争，降低成本，清理库存。</li><li><strong>商业银行</strong>：放宽信贷条件，支持小微企业，增加流动性。</li><li><strong>央行</strong>：降低利率，实施量化宽松，增加货币供给。</li><li><strong>政府</strong>：扩大财政支出，减税，增加公共投资，刺激需求。</li></ul><h3 id="未能及时处理通货紧缩的后果："><a href="#未能及时处理通货紧缩的后果：" class="headerlink" title="未能及时处理通货紧缩的后果："></a>未能及时处理通货紧缩的后果：</h3><h4 id="个人：-1"><a href="#个人：-1" class="headerlink" title="个人："></a>个人：</h4><ul><li><strong>消费意愿降低</strong>：预期价格将进一步下降，推迟购买，导致需求疲软。</li><li><strong>就业困难</strong>：企业缩减规模，新职位减少，失业率上升。</li><li><strong>债务负担加重</strong>：实际债务水平上升，偿债压力增大。</li></ul><h4 id="企业：-1"><a href="#企业：-1" class="headerlink" title="企业："></a>企业：</h4><ul><li><strong>销售下滑</strong>：市场需求减少，库存积压，利润减少。</li><li><strong>投资减少</strong>：对未来预期悲观，减少扩张和研发投资。</li><li><strong>财务困境</strong>：资产价值下降，资产负债表恶化，融资成本上升。</li></ul><h4 id="商业银行：-1"><a href="#商业银行：-1" class="headerlink" title="商业银行："></a>商业银行：</h4><ul><li><strong>信贷需求萎靡</strong>：企业和个人借款意愿低，银行盈利能力下降。</li><li><strong>资产质量下降</strong>：贷款违约率可能上升，不良资产增加。</li><li><strong>流动性陷阱</strong>：即使利率极低，也无法刺激借贷和投资。</li></ul><h4 id="央行：-1"><a href="#央行：-1" class="headerlink" title="央行："></a>央行：</h4><ul><li><strong>政策空间受限</strong>：利率接近零下限，传统货币政策工具效力有限。</li><li><strong>金融稳定性风险</strong>：长期通缩可能引发银行系统性风险。</li><li><strong>信任挑战</strong>：市场对央行刺激经济的能力产生怀疑。</li></ul><h4 id="政府：-1"><a href="#政府：-1" class="headerlink" title="政府："></a>政府：</h4><ul><li><strong>税收减少</strong>：经济活动放缓，政府税收减少，财政状况恶化。</li><li><strong>刺激政策效果有限</strong>：财政刺激措施可能因需求不足而效果打折。</li><li><strong>长期增长潜力受损</strong>：通缩可能导致经济陷入长期停滞，影响发展潜力。</li></ul><h2 id="中央银行印发的货币是如何进入市场的"><a href="#中央银行印发的货币是如何进入市场的" class="headerlink" title="中央银行印发的货币是如何进入市场的"></a>中央银行印发的货币是如何进入市场的</h2><p>现代社会中，当市场上的商品流通量增加时，如果货币量不变，就会发生通货紧缩，此时需要发行货币，可是中央银行印发的货币又是如何进入市场的呢，举一个通俗的例子讲解一下<br>当市场上的商品流通量增加，如果货币量不变，确实可能导致通货紧缩，因为流通中的货币不再能满足增加的商品交换需求，可能会引起货币购买力上升、物价普遍下降。为了应对这种情况，中央银行可能需要增加货币供应量，以维持经济的平稳运行。下面通过一个通俗的例子来解释中央银行如何将新发行的货币送入市场：<br>假设在一个小镇上，这个小镇上只有一个中央面包店和几家杂货店，居民们用金币进行交易。起初，镇上流通的金币刚好足够大家购买所需的面包和其他杂货，经济运行良好。<br><strong>情况变化</strong>：某一年，镇上的面包店引进了新技术，生产效率大大提高，能产出更多的面包，杂货店也增加了商品种类，整体上市场上的商品流通量增加了。但金币的总量没变，这时<strong>人们发现手中的金币不够用了</strong>，因为要买同样多的面包和其他物品，需要更多的金币。如果金币还是那么多，那么每个金币能买到的东西就变多了，这就是通货紧缩的表现。对个人来说，虽短期内购买力提升，但长期可能由于企业销售额下滑，利润减少，个人会面临失业风险，收入减少，由此会引发贷款违约风险增加，信贷收缩，盈利困难，政府的税收减少，财政收入下降，公共支出压力增大。<br><strong>中央银行行动</strong>：在这个小镇的比喻中，假设有一个类似于中央银行的机构，它意识到这个问题后，决定增发金币来匹配增加的商品供应。中央银行不是简单地把金币扔到街上，而是通过一系列机制让新金币逐步进入流通。<br><strong>具体操作</strong>：这个“中央银行”可能会采取以下步骤：</p><ol><li><strong>购买国债</strong>：它从政府那里购买国债，支付方式是新铸造的金币。政府拿到这些金币后，可以用来支付公共服务项目或补贴，这样金币就流入了经济体系。</li><li><strong>向商业银行提供贷款</strong>：通过再贴现、再贷款等操作，中央银行向商业银行提供新金币作为贷款，银行再将这些资金以贷款的形式提供给企业和个人，企业和个人用这些资金进行投资和消费，金币进一步分散到市场中。</li><li><strong>公开市场操作</strong>：在更复杂的经济环境中，中央银行还可以直接在公开市场上购买资产，比如政府债券或企业债券，向市场注入金币，提高银行体系的准备金，鼓励银行放贷，增加货币供给。<br><strong>最终效果</strong>：随着这些新金币通过不同的渠道进入市场，居民们发现手头的钱多了，可以购买更多商品，之前因商品增多而可能出现的通货紧缩压力得到缓解，经济活动得以继续健康开展。这个过程就像是给干涸的河流注入了新的水源，使得经济之船能够顺利航行。</li></ol><h2 id="长期通胀的后果"><a href="#长期通胀的后果" class="headerlink" title="长期通胀的后果"></a>长期通胀的后果</h2><p>在上述例子中，如果通货紧缩的情况得不到改善，因为某些原因迟迟没有更多金币进入市场，接下来会发生什么<br>如果通货紧缩的情况持续存在，且没有更多的金币（或货币）进入市场，接下来可能会发生以下几种情况：</p><ol><li><strong>物价持续下降</strong>：由于货币供应量相对商品和服务的供应量过少，购买相同数量的商品和服务需要的货币减少，导致物价持续下降。短期内，消费者可能会感到购买力增强，但这也会抑制企业利润。</li><li><strong>消费和投资减少</strong>：随着物价不断下跌，消费者可能会选择推迟购买，期望将来以更低价格购买同样的商品，这种现象被称为“需求递延”。同时，企业面对产品价格下降和未来预期悲观，可能会减少投资，避免在收益不确定的环境下扩大生产。</li><li><strong>企业盈利下降</strong>：物价下跌导致销售收入减少，但企业成本（如固定成本）可能并不会同比例下降，这会压缩企业的利润空间，甚至导致亏损。长期下去，一些企业可能因无法承受亏损而破产或关闭。</li><li><strong>失业率上升</strong>：企业减少投资和生产，可能导致裁员或减少招聘，进而推高失业率。失业人口增加，又会进一步抑制消费需求，形成恶性循环。</li><li><strong>债务负担加重</strong>：在通货紧缩环境中，虽然货币变得更值钱，但对于负债者而言，他们需要支付的固定金额债务实际上变得更加昂贵，因为用更值钱的货币偿还同样面额的债务意味着要付出更多实际价值的货物或服务，这会加重个人和企业的债务负担。</li><li><strong>信贷市场收缩</strong>：银行和其他金融机构可能因为担心贷款难以回收，加上储户偏好现金持有（因为现金随时间增值），而变得不愿意放贷，信贷市场紧缩，进一步抑制经济活动。</li><li><strong>经济衰退</strong>：如果这种情况持续，整个经济体可能会陷入衰退，经济增长停滞，甚至出现负增长。<br>总之，如果通货紧缩的问题得不到解决，可能会对经济造成深远的负面影响，因此政府和中央银行通常会采取积极措施，如前面提到的增加货币供应、降低利率等手段，来防止这种情况的发生或减轻其影响。</li></ol><h2 id="同样以这个小镇面包店的模型为例，在这个模型中发生通货膨胀的可能的原因有哪些？"><a href="#同样以这个小镇面包店的模型为例，在这个模型中发生通货膨胀的可能的原因有哪些？" class="headerlink" title="同样以这个小镇面包店的模型为例，在这个模型中发生通货膨胀的可能的原因有哪些？"></a>同样以这个小镇面包店的模型为例，在这个模型中发生通货膨胀的可能的原因有哪些？</h2><p>在这个小镇面包店的模型中，发生通货膨胀的可能原因主要包括以下几点：</p><ol><li><strong>需求拉动型通货膨胀</strong>：假设小镇的经济突然繁荣，居民收入增加，大家对面包和其他商品的需求急剧上升。如果面包店和其他杂货店的生产能力没有相应扩大，无法满足突然增加的需求，就会出现过多的货币追逐过少的商品的情况。这时，商家可能会提高商品价格以应对供不应求的局面，从而引发通货膨胀。</li><li><strong>成本推动型通货膨胀</strong>：如果面包店的原材料成本上升，比如小麦价格因干旱减产而上涨，或是燃料成本增加导致运输费用上升，面包店为了保持利润水平，可能会提高面包的价格。其他店铺也可能因为类似的成本增加而涨价。这样，整个市场的商品价格都将上涨，导致通货膨胀。</li><li><strong>货币超发</strong>：如果小镇的“中央银行”为了刺激经济或应对财政赤字，无节制地增发金币，而实际的商品和服务并没有相应增加，过多的货币追逐有限的商品，将导致物价普遍上涨，这也是通货膨胀的一个常见原因。</li><li><strong>预期因素</strong>：如果居民和企业预期未来价格会上涨，他们可能会提前增加购买和投资，这种行为本身会加剧需求，推动价格更快上涨，形成一个自我实现的预言，即使没有实质性的供需失衡或成本增加。</li><li><strong>信贷扩张</strong>：如果小镇上的银行放宽信贷条件，导致贷款变得容易获取，居民和企业借贷增加，用于消费和投资的资金增多，也会推高总需求，从而可能引起通货膨胀。</li><li><strong>外部冲击</strong>：小镇经济也可能受到外部因素的影响，比如国际市场大宗商品价格上涨，进口成本增加，或者国际资本流动带来货币供应量的变化，这些都可能成为通货膨胀的触发因素。<br>综上所述，通货膨胀在小镇模型中可能由多种因素单独或共同作用引发，涉及需求、成本、货币供应、预期心理以及外部环境等多个方面。</li></ol><h2 id="通缩时超发的货币引发未来的通胀"><a href="#通缩时超发的货币引发未来的通胀" class="headerlink" title="通缩时超发的货币引发未来的通胀"></a>通缩时超发的货币引发未来的通胀</h2><p>在一个有多种商品流通的市场里，例如我们在这个有小麦田和面包店的小镇里再添加伐木场和家具厂，当小镇能够出口面包后，小镇居民的收入提高，大家希望购买更多家具，但是家具厂无法满足需求，因此家具厂提高了家具的价格。这时家具的价格是虚高的，此时超发的货币会比未来家具厂扩大生产后的币值低，实际上是通货膨胀了。<br>您的描述非常形象地说明了一个特定场景下的通货膨胀过程。让我们详细分析这个过程：</p><ol><li><strong>收入增加导致需求增加</strong>：小镇开始出口面包，居民的收入因此提高，他们的购买力增强，对非必需品如家具的需求也随之上升。这种需求的增长超过了现有家具厂的生产能力。</li><li><strong>供不应求导致价格上升</strong>：家具厂面对突然增加的需求，如果短期内无法扩大生产规模（可能受限于原料、劳动力、设备等因素），无法满足市场需求，按照市场经济的原则，家具厂可能会选择提高价格以平衡供需。这时，家具价格的上涨并不是因为制造成本的直接增加，而是因为需求超过了供给能力，所以您说的“虚高”在这里指的是相对于原本供需平衡状态下的价格而言。</li><li><strong>货币超发加剧通货膨胀</strong>：如果在这个过程中，小镇的“中央银行”为了刺激经济或支持其他项目，发行了超出实际经济增长所需的货币量，这会导致市场上流通的货币总量增加。在商品和服务的供应没有同步增长的情况下，过多的货币追逐相对固定数量的商品，将进一步推高价格，加剧通货膨胀。</li><li><strong>未来生产调整与价格回归</strong>：随着时间的推移，如果家具厂成功扩大生产，增加了市场上的家具供应，理论上供需关系会重新达到平衡，过高的价格可能会逐渐回调。但是，在这个过程中，如果已经发生了明显的通货膨胀，即便未来价格有所回落，之前超发的货币已经造成了总体物价水平的上升，居民手中的货币购买力相对下降，这就是通货膨胀带来的实际损失。<br>总结来说，您提到的情形确实是通货膨胀的一个典型例子，其中包含需求拉动、供给约束以及货币超发的因素。关键在于，即使未来生产扩大后价格可能调整，超发的货币已经导致了整体物价水平的提升，影响了经济的稳定性。</li></ol><h2 id="“滚动债务”或“借新还旧”"><a href="#“滚动债务”或“借新还旧”" class="headerlink" title="“滚动债务”或“借新还旧”"></a>“滚动债务”或“借新还旧”</h2><p>实际上在现实中，随着技术地革新生产力提高，居民和企业的收入和消费的增加带来的税收增加，政府和企业通常会通过借新还旧的方式，只要它们能保证未来的收入是提升的，能够覆盖掉债务的利息，不断地通过新借到的钱偿还以前欠的债，然后用中间的差额去消费和投资<br>确实，您描述的现象在现实经济中是常见的做法，即所谓的“滚动债务”或“借新还旧”。这种方法基于对未来收入增长的信心，允许政府和企业维持或扩大现有的债务规模，同时为当前的消费和投资活动提供资金。以下是这一做法的几个关键点：</p><ol><li><strong>经济增长与税收增加</strong>：随着技术进步和生产力的提高，经济整体倾向于增长，这通常会带动居民和企业收入的增加，进而通过税收等形式增加政府的收入。更高的收入为政府偿还债务提供了基础。</li><li><strong>借新还旧策略</strong>：政府和企业利用新发行债券或其他形式的融资所得，来偿还即将到期的债务本金和利息，而不是一次性全部偿还债务。这样做可以避免一次性大额偿债对现金流的冲击，同时保持资金的连续性使用。</li><li><strong>利息覆盖能力</strong>：关键在于确保新借入资金的利息成本可以被预期的收入增长所覆盖。只要未来的收入增长能够持续，且超过债务成本，这种模式就可以持续运行。</li><li><strong>投资与消费促进</strong>：通过这种方式腾出的资金可以被用于新的投资，比如基础设施建设、教育、研发等领域，或者用于刺激消费，促进经济的进一步增长，形成良性循环。<br>然而，这种策略也有风险，包括：</li></ol><ul><li><strong>债务累积风险</strong>：长期依赖借新还旧可能导致债务总额不断累积，一旦经济增长放缓或遭遇经济危机，收入增长不如预期，可能会难以维持债务的可持续性。</li><li><strong>利息负担加重</strong>：随着债务规模的扩大，即使利率保持不变，总的利息支出也会增加，可能占用越来越多的财政或企业资源。</li><li><strong>信用评级影响</strong>：持续的高额债务和频繁的借新还旧可能会影响政府或企业的信用评级，增加未来融资的成本。<br>因此，虽然借新还旧是一种常用的财务管理策略，但也需要谨慎实施，确保不会积累不可持续的债务风险。</li></ul><h2 id="再贴现"><a href="#再贴现" class="headerlink" title="再贴现"></a>再贴现</h2><p>假设小镇上有一家商业银行，它之前向面包店发放了一笔贷款，面包店用这笔钱购买面粉和燃料，生产出面包销售给居民。一段时间后，面包店开始偿还这笔贷款给商业银行，并附带有利息。然而，有时候面包店可能无法立即以现金还款，而是给了商业银行一张自己开出的、有一定期限的借据（称为“票据”）。这张票据就是面包店承诺在未来某一时间支付给银行一定金额的凭证。<br>这时候，商业银行如果需要增加自己的流动资金（比如为了应对存款提取或新的贷款需求），它可以拿着这张票据去找中央银行，请求中央银行提前兑换现金。这个过程就叫做“再贴现”。中央银行审核票据后，会扣除一定的折扣（即贴现率），（贴现）即中央银行支付给商业银行的款项低于票据面额的部分，这部分差额实际上是商业银行为了提前获得资金所支付的融资成本。然后把剩下的钱给商业银行。这样，商业银行得到了即时的流动性，而中央银行通过这种方式间接向市场注入了新的货币。</p><h2 id="再贷款"><a href="#再贷款" class="headerlink" title="再贷款"></a>再贷款</h2><p>再贷款则是另一种形式的支持。如果商业银行直接向中央银行申请贷款，以补充自身的资金短缺或满足法定准备金要求，这就叫再贷款。比如，小镇的商业银行可能因为居民存款大量提取或贷款需求激增，导致资金紧张。这时，它可以直接向中央银行申请贷款，中央银行审核后会提供所需资金，银行支付一定的利息给中央银行。这个过程中，中央银行实际上是直接向商业银行提供了新增的资金，增加了市场上的货币供应量。</p><h2 id="最后贷款人"><a href="#最后贷款人" class="headerlink" title="最后贷款人"></a>最后贷款人</h2><p>“最后贷款人”是指中央银行在银行体系面临流动性危机时，向遇到资金困难的商业银行或其他合格金融机构提供紧急资金援助的角色。这一机制旨在防范系统性金融风险，确保金融稳定。中央银行作为最后贷款人的主要目标是通过提供必要的流动性支持，帮助遇到临时性资金短缺的金融机构维持正常运营，避免银行挤兑、支付系统中断等危机情况的发生。这一角色的确立强化了中央银行在金融体系中的核心地位，同时也体现了政府作为行政力量在市场经济中的宏观调控作用，其援助并非无条件救助，而是为了稳定市场信心，维护整个金融体系的健康运行。</p><h2 id="央行与商业银行的本质区别"><a href="#央行与商业银行的本质区别" class="headerlink" title="央行与商业银行的本质区别"></a>央行与商业银行的本质区别</h2><ol><li><strong>职能定位</strong>：中央银行主要负责制定和执行货币政策，管理国家货币供应量，控制通货膨胀，以及维护金融稳定。而商业银行则侧重于提供金融服务，如吸收存款、发放贷款、提供支付结算服务等，其目标是追求利润最大化。</li><li><strong>资金来源与使用</strong>：中央银行拥有货币发行权，可以通过多种途径（如购买国债、再贴现、公开市场操作）调节货币供应，而无需提供传统意义上的贷款抵押物。商业银行则依赖于存款、股东资本、金融市场融资等方式获得资金，并基于风险评估和贷款政策向企业和个人提供贷款。</li><li><strong>风险承担与资本要求</strong>：商业银行在发放贷款时，需评估贷款风险并保留相应资本缓冲以应对可能的损失，其运营直接受到市场风险的影响。中央银行作为货币发行者，其信用基础是国家主权，通常不存在破产风险，其风险承担和资本要求与商业银行有本质不同。</li><li><strong>目标与责任</strong>：中央银行的目标是宏观经济稳定，包括控制通货膨胀、促进经济增长、维护金融稳定等，而商业银行的目标是股东回报最大化，即通过有效管理风险和资本，提供金融服务并赚取利润。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哈佛光谱分类</title>
    <link href="/2024/06/22/%E5%93%88%E4%BD%9B%E5%85%89%E8%B0%B1%E5%88%86%E7%B1%BB/"/>
    <url>/2024/06/22/%E5%93%88%E4%BD%9B%E5%85%89%E8%B0%B1%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>哈佛系统是天文学家 安妮 江浦 坎农(Annie Jump Cannon) 的一维分类方案，他重新排序了德雷伯(Draper)之前的字母系统。恒星根据其光谱特征按字母表的单个字母进行分组，并可选择使用字母细分。</p><table><thead><tr><th>分类</th><th>温度</th><th>色度</th><th>主序质量</th><th>主序半径</th><th>主序光度</th><th>主序星比例</th></tr></thead><tbody><tr><td>O</td><td>&gt;&#x3D;33000K</td><td>蓝</td><td>&gt;&#x3D;16</td><td>&gt;&#x3D;6.6</td><td>&gt;&#x3D;30000</td><td>0.00003%</td></tr><tr><td>B</td><td>10000-33000K</td><td>深蓝白色</td><td>2.1-16</td><td>1.8-6.6</td><td>25-30000</td><td>0.12%</td></tr><tr><td>A</td><td>7300-10000K</td><td>蓝白色</td><td>1.4-2.1</td><td>1.4-1.8</td><td>5-25</td><td>0.61%</td></tr><tr><td>F</td><td>6000-73000K</td><td>白</td><td>1.04-1.4</td><td>1.15-1.4</td><td>1.5-5</td><td>3.0%</td></tr><tr><td>G</td><td>5300-6000K</td><td>黄白色</td><td>0.8-1.04</td><td>0.96-1.15</td><td>0.6-1.5</td><td>7.6%</td></tr><tr><td>K</td><td>3900-5300K</td><td>淡黄橙色</td><td>0.45-0.8</td><td>0.7-0.96</td><td>0.08-0.6</td><td>12%</td></tr><tr><td>M</td><td>2300-3900K</td><td>浅橙红色</td><td>0.08-0.45</td><td>&lt;&#x3D;0.7</td><td>&lt;&#x3D;0.08</td><td>76%</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>官僚垄断资本主义、平台资本主义、数字封建主义</title>
    <link href="/2024/06/22/%E5%AE%98%E5%83%9A%E5%9E%84%E6%96%AD%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E3%80%81%E5%B9%B3%E5%8F%B0%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E3%80%81%E6%95%B0%E5%AD%97%E5%B0%81%E5%BB%BA%E4%B8%BB%E4%B9%89/"/>
    <url>/2024/06/22/%E5%AE%98%E5%83%9A%E5%9E%84%E6%96%AD%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E3%80%81%E5%B9%B3%E5%8F%B0%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E3%80%81%E6%95%B0%E5%AD%97%E5%B0%81%E5%BB%BA%E4%B8%BB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h2 id="官僚垄断资本主义"><a href="#官僚垄断资本主义" class="headerlink" title="官僚垄断资本主义"></a>官僚垄断资本主义</h2><p>官僚垄断资本主义是一种资本主义形式，其中资本主义生产方式与政治权力紧密融合，形成了垄断性的国家垄断资本主义。在这种体系中，政府官僚机构与大资本家集团关系密切，政府通过直接控制或强烈影响关键经济领域，如基础设施、自然资源和重要产业，来维护特定资本利益。官僚垄断资本主义的特征包括：</p><ul><li><strong>政治权力与经济力量的联姻</strong>：政府官员和大型企业之间存在紧密的联系，政府可能直接经营企业或通过法规为特定企业提供保护和优势。</li><li><strong>市场准入限制</strong>：通过政策和法规限制竞争，保护特定企业和行业免受外来竞争，维持垄断地位。</li><li><strong>资源分配不公</strong>：资源和机会倾向于集中在少数政治和经济精英手中，加剧社会不平等。</li><li><strong>决策非市场化</strong>：经济决策往往受到政治考量的影响，而非完全由市场需求驱动。</li></ul><h2 id="平台资本主义"><a href="#平台资本主义" class="headerlink" title="平台资本主义"></a>平台资本主义</h2><p>平台资本主义是数字经济时代的一种新现象，指的是基于互联网平台的商业模式，这些平台通过聚合用户、数据、服务和产品，形成强大的市场中介。平台资本主义的核心特征包括：</p><ul><li><strong>数据驱动</strong>：平台通过收集、分析用户数据，实现精准营销、定制服务，从而创造价值。</li><li><strong>双边市场</strong>：连接供应商和消费者，通过规模经济和网络效应迅速扩张，形成市场垄断或寡头。</li><li><strong>灵活用工</strong>：促进了零工经济和数字劳工的兴起，劳动者与平台的关系趋向松散，权益保护成为挑战。</li><li><strong>监管挑战</strong>：由于其新颖性和跨界性，平台资本主义经常超出传统监管框架，引发关于数据隐私、竞争政策和劳动权益的讨论。</li></ul><h2 id="数字封建主义"><a href="#数字封建主义" class="headerlink" title="数字封建主义"></a>数字封建主义</h2><p>数字封建主义是一个较新的概念，用来形容一种可能的未来社会结构，其中数字平台和科技巨头通过控制数据、算法和关键技术，建立起类似封建时代的等级制度。在这个模型中：</p><ul><li><strong>技术领主与数字农奴</strong>：少数掌握核心数字资源的企业如同领主，而广大用户和依赖平台的工作者则像依附于土地的农奴，他们的生计和活动受限于平台规则。</li><li><strong>信息不对称</strong>：平台拥有对数据的绝对控制权，普通用户对个人信息的使用和价值创造过程缺乏透明度和控制。</li><li><strong>经济依赖性</strong>：用户和小型企业对大平台的服务高度依赖，很难脱离平台生态系统独立生存。</li><li><strong>社会分化加剧</strong>：随着数字鸿沟的加深，技术资源的不平等分配可能导致社会阶层更加固化，形成新的不平等结构。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>外汇储备</title>
    <link href="/2024/06/22/%E5%A4%96%E6%B1%87%E5%82%A8%E5%A4%87/"/>
    <url>/2024/06/22/%E5%A4%96%E6%B1%87%E5%82%A8%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>外汇储备是由企业结汇获得的。外汇是由企业出口（或者外资投资）获得的，而企业出口获得的外汇无法直接在国内使用，需要进行兑换，而央行（通过商业银行）获得外汇之后，资产负债表上资产（外汇储备）增加，则需要相应的负债（货币发行）。<br>我持有的美元债务，实际上已经有等额人民币存在于中国市场上。企业去兑换美元（结汇）的时候从银行拿到的人民币，就是对应这笔外汇印出来的钱。这笔人民币叫外汇占款。</p><h2 id="外汇储备的三个用途"><a href="#外汇储备的三个用途" class="headerlink" title="外汇储备的三个用途"></a>外汇储备的三个用途</h2><h3 id="用于国内企业国际结算"><a href="#用于国内企业国际结算" class="headerlink" title="用于国内企业国际结算"></a>用于国内企业国际结算</h3><p>我国企业在进口时，需要美元，就需要用等值的人民币兑换外汇，支付给外国企业。或者外国企业（或者老外在中国工作）在中国赚了钱，需要带回去，就得把手里的人民币换成外汇带走，这个时候就要用到外汇储备，把市场上对应的人民币收回。（央行的资产负债表上资产负债同时减少，相当于回收货币）</p><h3 id="政府间国际援助、结算"><a href="#政府间国际援助、结算" class="headerlink" title="政府间国际援助、结算"></a>政府间国际援助、结算</h3><p>援助、交联合国会费之类。或者国际军火贸易。</p><h3 id="稳定汇率"><a href="#稳定汇率" class="headerlink" title="稳定汇率"></a>稳定汇率</h3><p>在适当的时候在市场上抛售外汇买入人民币使人民币升值</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>布莱克舒尔斯期权定价模型</title>
    <link href="/2024/06/22/%E5%B8%83%E8%8E%B1%E5%85%8B%E8%88%92%E5%B0%94%E6%96%AF%E6%9C%9F%E6%9D%83%E5%AE%9A%E4%BB%B7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/06/22/%E5%B8%83%E8%8E%B1%E5%85%8B%E8%88%92%E5%B0%94%E6%96%AF%E6%9C%9F%E6%9D%83%E5%AE%9A%E4%BB%B7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>布莱克-舒尔斯（Black-Scholes）期权定价模型是一种用于计算欧式期权价格的数学模型，被认为是金融工程领域的重要成就之一。它由费希尔·布莱克（Fischer Black）和默顿·舒尔斯（Myron Scholes）在1973年提出，并于1997年诺贝尔经济学奖颁给这两位经济学家，以表彰他们的贡献。</p><h2 id="模型基本假设："><a href="#模型基本假设：" class="headerlink" title="模型基本假设："></a>模型基本假设：</h2><ol><li><p><strong>市场假设</strong>：</p><ul><li>市场是有效的，不存在套利机会。</li><li>资产价格遵循几何布朗运动（Geometric Brownian Motion），即其价格的变化服从随机游走模型。</li></ul></li><li><p><strong>基本参数</strong>：</p><ul><li><strong>标的资产价格</strong> $S_t$：标的资产在时间 $t$ 的价格。</li><li><strong>行权价格</strong> $K$：期权的行权价格，即标的资产的约定购买或卖出价格。</li><li><strong>到期时间</strong> $T$：期权的到期时间。</li><li><strong>无风险利率</strong> $r$：期间内可获得的无风险利率。</li><li><strong>标的资产波动率</strong> $\sigma$：标的资产的年化波动率。</li></ul></li></ol><h2 id="模型公式："><a href="#模型公式：" class="headerlink" title="模型公式："></a>模型公式：</h2><p>布莱克-舒尔斯模型基于偏微分方程，它的基本公式为：</p><p>$$<br>C(S_t, t) &#x3D; S_t \cdot N(d_1) - K \cdot e^{-r(T-t)} \cdot N(d_2)<br>$$</p><p>$$<br>P(S_t, t) &#x3D; K \cdot e^{-r(T-t)} \cdot N(-d_2) - S_t \cdot N(-d_1)<br>$$</p><p>其中：</p><ul><li>$C(S_t, t)$ 和 $P(S_t, t)$ 分别表示欧式看涨期权和看跌期权的价格。</li><li>$N$ 是标准正态分布的累积分布函数。</li><li>$d_1$ 和 $d_2$ 是根据以下公式计算的：</li></ul><p>$$<br>d_1 &#x3D; \frac{\ln(S_t &#x2F; K) + (r + \frac{\sigma^2}{2})(T - t)}{\sigma \sqrt{T - t}}<br>$$</p><p>$$<br>d_2 &#x3D; d_1 - \sigma \sqrt{T - t}<br>$$</p><h2 id="解释和应用："><a href="#解释和应用：" class="headerlink" title="解释和应用："></a>解释和应用：</h2><ul><li><strong>定价原理</strong>：布莱克-舒尔斯模型通过考虑标的资产价格的随机波动性、期权行权价格、时间价值和无风险利率，计算出一个合理的期权价格。</li><li><strong>波动率的影响</strong>：模型中的一个关键参数是标的资产的波动率 $\sigma$，它反映了市场对资产未来波动性的预期。波动率越高，期权的价格通常也会越高。</li><li><strong>应用范围</strong>：布莱克-舒尔斯模型主要适用于欧式期权（即只能在到期日行使的期权），并且假设市场是无套利的和免除交易成本的情况下。</li></ul><p>布莱克-舒尔斯模型为金融市场提供了一种理论框架，使得投资者和金融机构能够更准确地定价和交易期权，同时也促进了对金融衍生品定价理论的深入研究和发展。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是朋克？</title>
    <link href="/2024/03/16/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8B%E5%85%8B%EF%BC%9F/"/>
    <url>/2024/03/16/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8B%E5%85%8B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>朋克的意义就是否定和摧毁固有的与保守的——<strong>然后重建</strong>。</p><p>科幻中的朋克就是借用流行文化里的朋克的概念，把现在的世界形态打碎，在某个时间点里建立一个新形态的世界。例如赛博朋克建立了一个高科技低生活的未来世界，赛博空间和仿生人技术高度发达，并且大部分时候故事背景在太空时代。原子朋克设想了一个原子能高度发达的社会，世界处于冷战背景下，美好的生活随时会化为泡影。蒸汽朋克则是把高科技造物换了个蒸汽机风格的外壳，然后塞到维多利亚时期风格的背景里。朋克是故事的核心，而赛博控制论或蒸汽机则是故事的背景，通过这些有趣的置换，故事的丰富程度得到极大的提高，表达内核的方式也更加丰富。</p><h2 id="赛博朋克"><a href="#赛博朋克" class="headerlink" title="赛博朋克"></a>赛博朋克</h2><blockquote><p>下面这段使用ai模仿生成</p></blockquote><p>赛博朋克是一种深受科幻和网络技术影响的设计风格，它起源于20世纪70年代至80年代的科幻小说和电影，特点是高科技与低生活水平的结合。赛博朋克的典型特征包括高度发达的计算机和网络技术、人工智能、生物工程、霓虹灯和摩天大楼等元素。这种风格通常描绘出一个充满未来感和科技感的世界，但同时也强调了社会的不公和人类道德的沦丧。赛博朋克作品通常探讨人类与机器、真实与虚拟、自由与控制等主题，同时也传达出对现代科技的担忧和对人类未来的思考。在赛博朋克作品中，常常出现一些具有超强能力的黑客、雇佣兵和反抗者等角色。</p><h2 id="原子朋克"><a href="#原子朋克" class="headerlink" title="原子朋克"></a>原子朋克</h2><p>原子朋克是一种比较完整的设计风格，但最开始是始于游戏作品中，原子能进入民用市场，电子管计算机大规模发展并且晶体管还未出现，各种原子朋克风格的物品，颜色鲜艳，线条圆润简洁，充满未来感，构成了不同寻常的世界观。在这类作品中更多的将原子朋克当成一种外观设计语言，并且游戏多发生在后启示录背景下，且多是冷战以大规模核武器互相毁灭后的世界为背景，在不特别说明的情况下，这种故事的背景大多是在美苏冷战时期。这样做方便叙事，且避开了庞大繁杂的社会，主角只需要在辐射废土上演绎他的故事。这种故事也往往传达出强烈的反乌托邦主义思想——即使是在这种有着无限能源的社会中，两大霸主之间的竞争也最后导致了美好的生活和未来一切的消失。</p><p>在2023年2月发售的游戏《原子之心》中，特工P3也是在一片机器人叛乱后的“废土”世界中，逐步揭开理想世界背后的真相。本作中即出现了众多具有鲜明的原子朋克风格设计的机器人，使人想起辐射系列中的“噶爪”等机器人和动力机甲，但该作品不同于《辐射》在于，其非开放世界的线性叙事结构和解谜元素，展现出了更多创作者的设计意图之外，也让美术资源得到了最大化的利用，让玩家充分领略了一个充满了机器人和自动化机械的乌托邦世界，以及失去这一切之后的惨烈现实。</p><h2 id="蒸汽朋克"><a href="#蒸汽朋克" class="headerlink" title="蒸汽朋克"></a>蒸汽朋克</h2><blockquote><p>下面这段使用ai模仿生成</p></blockquote><p>蒸汽朋克是一种以蒸汽动力和工业革命为背景的设计风格，它起源于20世纪80年代至90年代的科幻小说和电影。蒸汽朋克的典型特征包括巨大的齿轮、蒸汽机、煤炭和钢铁等元素，以及维多利亚时代的建筑和服装风格。这种风格通常描绘出一个充满历史感和机械感的时代，但同时也强调了科技和工业的发展对环境和人类的影响。蒸汽朋克作品通常探讨工业革命和科技进步带来的社会变革和道德问题，同时也传达出对现代科技的担忧和对人类未来的思考。在蒸汽朋克作品中，常常出现一些具有独特技能和智慧的发明家、探险家和革命者等角色。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Design on Code（基于代码的设计）</title>
    <link href="/2024/03/15/Design%20on%20Code(%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1)/"/>
    <url>/2024/03/15/Design%20on%20Code(%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1)/</url>
    
    <content type="html"><![CDATA[<p>“Design on Code” 理念，也称为“基于代码的设计”或“编码设计”，是一种软件开发方法，它强调在编写代码的过程中进行设计和规划。这种方法与传统的“先设计后编码”的方法有所不同，它认为设计应该是逐步演进的，而不是在编码之前完全确定的。</p><p>“Design on Code”理念的一些主要特点：</p><ol><li><strong>迭代和演进</strong>：鼓励开发人员通过迭代和演进的方式来构建软件。这意味着设计会在编码过程中逐渐变得清晰，而不是一开始就完全确定。</li><li><strong>灵活性</strong>：由于设计是逐步形成的，提供了更大的灵活性，允许开发人员根据实际需求进行调整和修改。</li><li><strong>代码质量</strong>：通过直接在代码中实现设计，开发人员可以更容易地确保代码的质量和可维护性。鼓励编写简洁、清晰和可测试的代码。</li><li><strong>减少文档</strong>：与传统的设计方法相比，可能不需要编写大量的设计文档。相反，代码本身成为了设计的主要表达形式。</li><li><strong>强调实现</strong>：实现（即编码）是设计过程的重要组成部分。通过编写代码，开发人员可以更好地理解问题的本质，并据此调整设计。</li></ol><p>“Design on Code”理念并不是要完全摒弃传统的设计方法。在某些情况下，先进行详细的设计可能是必要的。然而，这种方法提供了一种不同的视角，强调在编码过程中进行设计和规划的重要性。</p><p>此外，这种方法可能更适合于某些类型的项目，如快速原型开发、敏捷开发或需要高度灵活性和适应性的项目。然而，在其他情况下，传统的先设计后编码方法可能更为合适。因此，在选择使用哪种方法时，需要根据项目的具体需求和团队的实际情况进行权衡。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unity 绑定（订阅）事件方式</title>
    <link href="/2024/03/15/Unity%20%E7%BB%91%E5%AE%9A(%E8%AE%A2%E9%98%85)%E4%BA%8B%E4%BB%B6%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/03/15/Unity%20%E7%BB%91%E5%AE%9A(%E8%AE%A2%E9%98%85)%E4%BA%8B%E4%BB%B6%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>事件的本质是delegate委托，C#本身封装了一个Event类（配合EventArgs使用更方便），Unity又将其包装为UnityEvent（然后就可以在unity的inspector里通过拖动脚本或物体来绑定事件）。<br>所以addlistener方法除了可以传入void参数的方法，即使用 <code>addlistener(nameof(methodname));</code> ；也可以传入委托，或使用表达式主体，即把委托成员的声明放在了表达式里而不是由编译器来构造委托。<br>事先强调一下这一点，之后就不用再回答一个低级问题了：“如何在addlistener()时为订阅的事件（方法）传入事件参数？”</p><h2 id="UGUI几种绑定事件的方法"><a href="#UGUI几种绑定事件的方法" class="headerlink" title="UGUI几种绑定事件的方法"></a>UGUI几种绑定事件的方法</h2><p>使用UGUI或NGUI这种现成的使用UnityEvent的框架时，可以很方便的拖动各种东西到事件列表里来绑定事件，看起来很方便，但实际上很混乱。</p><p>更好的办法是在事件所有类里，使用生命周期函数来订阅事件，这样当你因为某种原因需要修改方法名称或类的成员时，inspector里不会出现丢失引用的情况。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NewBehaviourScript</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br> <br>    Button btn;<br>    Toggle toggle;<br>    InputField inputField;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClickEvent</span>()</span>;<br>    <span class="hljs-keyword">public</span> ClickEvent clickEvent;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//1 直接AddListener(string 方法名)</span><br>        btn.onClick.AddListener(DoSomething);<br>        <span class="hljs-comment">//使用nameof()可以快速定位方法，便于调试，也可以用typeof()，但写起来较麻烦</span><br>        btn.onclick.AddListener(<span class="hljs-keyword">nameof</span>(DoSomething));<br>        <span class="hljs-comment">//2 Lamda表达式委托 有参</span><br>        btn.onClick.AddListener(() =&gt;<br>        &#123;<br>            DoSomething();<br>            Debug.Log(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">//可以传入更多方法作为参数</span><br>        &#125;);<br>        <span class="hljs-comment">//3 隐式委托</span><br>        btn.onClick.AddListener(<span class="hljs-built_in">delegate</span> ()<br>        &#123;<br>            DoSomething();<br>            Debug.Log(<span class="hljs-string">&quot;0&quot;</span>);<br>        &#125;);<br>        <span class="hljs-comment">//4 向委托添加方法</span><br>        clickEvent += DoSomething;<br>        <span class="hljs-comment">//5 EventTrigger</span><br>        EventTrigger trigger = btn.gameObject.GetComponent&lt;EventTrigger&gt;();<br>        EventTrigger.Entry entry = <span class="hljs-keyword">new</span> EventTrigger.Entry();<br>        entry.eventID = EventTriggerType.PointerClick;<span class="hljs-comment">//鼠标点击事件</span><br>        entry.callback = <span class="hljs-keyword">new</span> EventTrigger.TriggerEvent();<br>        entry.callback.AddListener(A);<br><br>        <span class="hljs-comment">//toggle</span><br>        toggle.onValueChanged.AddListener(ToggleAction);<br>        toggle.onValueChanged.AddListener(<span class="hljs-built_in">delegate</span> &#123; DoSomething()); &#125;);<br>        toggle.onValueChanged.AddListener(<span class="hljs-built_in">delegate</span> (<span class="hljs-built_in">bool</span> <span class="hljs-keyword">value</span>) &#123; DoSomething()); &#125;);<br>        toggle.onValueChanged.AddListener((<span class="hljs-keyword">value</span>) =&gt;<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span>)<br>            &#123; &#125;<br>            <span class="hljs-keyword">else</span> &#123; &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//InputField</span><br>        inputField.onValueChanged.AddListener(<span class="hljs-built_in">delegate</span><br>        &#123;<br>            DoSomething();<br>        &#125;);<br>        inputField.onEndEdit.AddListener(DoSomethingStr);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span> &#123; Debug.Log(<span class="hljs-string">&quot;Do Something&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomethingStr</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span> &#123; Debug.Log(str); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A</span>(<span class="hljs-params">BaseEventData data</span>)</span> &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ToggleAction</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> b</span>)</span> &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 常用API</title>
    <link href="/2024/02/24/Unity-%E5%B8%B8%E7%94%A8API/"/>
    <url>/2024/02/24/Unity-%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h2 id="Event-Function-事件函数-即生命周期函数"><a href="#Event-Function-事件函数-即生命周期函数" class="headerlink" title="Event Function:事件函数 &#x2F;&#x2F;即生命周期函数"></a>Event Function:事件函数 &#x2F;&#x2F;即生命周期函数</h2><p><code>Awake()</code> : 始终在任何 Start 函数之前（开始渲染之前）并在实例化预制件之后（一些manager脚本、网络等）调用此函数。如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。<br><code>OnEnable()</code> : 当将物体的SetActive设置为true时就会自动调用调用该方法。<br><code>Awake()</code>、<code>Start()</code> : 都是在游戏物体初始化运行一次，但是Awake的运行顺序高于Start的，并且只要脚本中存在Awake方法，则无论是否挂载了该脚本都会执行该方法。<br><code>Start()</code> :在游戏初始化时会执行一次，不是很紧急的初始化，一般放在Start里面来做。仅在Update函数第一次被调用前调用。<br><code>Fixed Update()</code> : 会按固定时间差重复执行，用在力学更新效果中。执行在Update之前。<br><code>Update()</code> : 每一帧都会运行这个方法，是用于帧更新的主要函数。<br><code>LateUpdate()</code> : 晚于Update的运行顺序，但是FPS和Update是一样的，一般人物的移动放在Update中，而摄像机的跟进变化放到FixedUpdate中。确保两个独立。<br><code>OnDisable()</code> : 物体被禁用时调用。<br><code>OnDestory()</code> : 当对象被销毁或关闭游戏时调用。<br><code>Reset()</code> : 被附加脚本时、在游戏物体的组件上按Reset时会触发该事件函数，调用 Reset 可以在脚本首次附加到对象时以及使用 ReSet 命令时初始化脚本的属性。</p><h2 id="Attribute-属性"><a href="#Attribute-属性" class="headerlink" title="Attribute 属性"></a>Attribute 属性</h2><p><code>[serializeField]</code>：将私有类型和保护类型的变量可视化到面板上<br><code>[System.serializedField]</code>：将自定义类型的变量可视化到面板上<br><code>[HideIninspector]</code>：在面板上隐藏公共变量<br><code>[Header(&quot;分组说明&quot;)]</code>：将公共变量进行分组<br><code>[Tooltip(&quot;提示信息&quot;)]</code>：鼠标悬浮在该变量上时显示说明信息<br><code>[Range(float min,float max)]</code>：通过拖动条的方式来控制范围<br><code>[contexMenuItem(string 变量名,方法名())]</code>：停在可视化变量上时显示方法，并可以点击调用，需要是无参数无返回值的方法<br><code>[contexMenu(&quot;方法名&quot;)]</code>：只为调试，右键选择方法执行<br><code>[Multline(n)]</code>：将字符串设置可见的n行<br><code>[TextArea(min,max)]</code>：添加滚动条来查看设置的文本区<br><code>[DisallowMulipleComponment]</code>：不允许挂载多重脚本</p><h2 id="Directory-路径"><a href="#Directory-路径" class="headerlink" title="Directory 路径"></a>Directory 路径</h2><h2 id="Corsor-鼠标指针"><a href="#Corsor-鼠标指针" class="headerlink" title="Corsor 鼠标指针"></a>Corsor 鼠标指针</h2><ul><li>CursorLockMode.Confined : 将光标限制在游戏窗体中</li><li>CursorLockMode.Locked : 光标锁定到视图的中心</li><li>CuesorLockMode.None : 无规定</li><li>Cursor.visible : 光标可见性</li><li>Input.mousePosition : 当前鼠标在像素坐标中的位置</li></ul><h2 id="Time-时间类函数"><a href="#Time-时间类函数" class="headerlink" title="Time 时间类函数"></a>Time 时间类函数</h2><ul><li>静态变量<ul><li>Time.time ：表示从游戏开发到现在的时间，会随着游戏的暂停而停止计算。</li><li>Time.timeSinceLevelLoad ： 表示从当前Scene开始到目前为止的时间，也会随着暂停操作而停止。</li><li>Time.deltaTime ： 表示从上一帧到当前帧时间，以秒为单位。【一般用来控制角色、动画的运动】</li><li>Time.fixedTime ： 表示以秒计游戏开始的时间，固定时间以定期间隔更新（相当于fixedDeltaTime）直到达到time属性。</li><li>Time.fixedDeltaTime ： 表示以秒计间隔，在物理和其他固定帧率进行更新，在Edit-&gt;ProjectSettings-&gt;Time的Fixed Timestep可以自行设置。</li><li>Time.SmoothDeltaTime： 表示一个平稳的deltaTime，根据前 N帧的时间加权平均的值。</li><li>Time.timeScale： 时间缩放，默认值为1，若设置 &lt; 1，表示时间减慢，若设置 &gt; 1,表示时间加快，可以用来加速和减速游戏，回放等、非常有用。如果游戏中控制运动的都是使用了Time.deltatime的话，则可以通过设置Time.timeScale&#x3D; 0来暂停其运动等。</li><li>Time.frameCount ： 总帧数</li><li>Time.realtimeSinceStartup  ： 表示自游戏开始后的总时间，即使暂停也会不断的增加。【一般用作性能测试】</li><li>Time.captureFramerate ： 表示设置每秒的帧率，然后不考虑真实时间。</li><li>Time.unscaledDeltaTime ： 以秒计算，完成最后一帧的时间 不考虑timescale时候与deltaTime相同，若timescale被设置，则无效。</li><li>Time.unscaledTime： 从游戏开始到现在所用的时间 不考虑timescale时候与time相同，若timescale被设置，则无效。</li></ul></li></ul><h2 id="GameObject-游戏物体"><a href="#GameObject-游戏物体" class="headerlink" title="GameObject 游戏物体"></a>GameObject 游戏物体</h2><ul><li>创建游戏物体<ul><li>创建空的游戏对象<br><code>new GameObejct(&quot;name&quot;);</code></li></ul></li><li>实例化创建游戏对象<br><code>public static Object Instantiate (Prefab name);</code>&#x2F;&#x2F;实例化一个预制件<br><code>public static Object Instantiate (Prefab name,Vector3 position,Quaternion rotation,Transform parent);</code>&#x2F;&#x2F;并且赋值它的位置、旋转、父物体transform<br>&#x2F;&#x2F;根据Prefab或者是另外一个游戏物体来创建（克隆Colon），可以实例粒子、等其他的游戏物体，常用<br>通过预制体实例化还可以使用 <code>Resources.Load&lt;GameObject&gt;(&quot;PrefabName&quot;);</code> 不区分大小写</li><li>创建基本的物体<br><code>CreatPrimitive(PrimitiveType);</code></li><li>添加组件<br><code>new GameObject(name);</code><br><code>name.AddComponent&lt;组件名&gt;();</code><br><code>name.AddComponent&lt;脚本名&gt;();</code></li><li>属性和变量<br><code>object.name</code>：对象的名称。<br><code>GameObject.SetActive(false/true)</code> ：通过参数的控制来设置其游戏物体的激活状态，true为激活状态，反之为取消激活状态。<br><code>GameObject.activeInHierarchy</code>： 游戏物体是否处于激活状态，与父类有关，父类被取消激活，则子类也是取消激活的。<br><code>GameObject.activeSelf</code> ： 自身的激活状态，与父类无关，只与自身有关。<br><code>GameObject.tag</code>： 游戏物体的tag标签，具体的由程序员自定义设置。</li><li>静态函数,共有方法，变量<br><code>Destroy()</code> ：删除游戏物体，但是不会立马在unity中删除，而是会先进行回收，等确定没对象使用的时候，在进行删除<br><code>DontDestroyOnLoad()</code> ： 当加载新的场景的时候，不删除这个场景中的某个游戏物体<br><code>FindObjectOfType\&lt;T&gt;()</code> ：通过类型T来进行查找对象，返回的是一个对象<br><code>FindObjectsOfType\&lt;T&gt;()</code>：通过类型T来进行查找对象，返回类型为Type的所有活动加载对象的列表。<br><code>FindGameObjectWithTag()</code> ：返回标记的Tag活动游戏对象。<br><code>FindGameObjectsWithTag()</code> ：返回标记的Tag活动游戏对象列表。如果没有GameObject(游戏物体)返回空数组</li><li>消息发送<br><code>BroadcastMessage()</code> ：广播发送消息，则该物体上对应的方法会被调用，同时这个游戏物体上的子物体上对应的方法也会被调用的<br><code>SendMessage()</code>：发送消息，只会对这个游戏物体中脚本上的方法发送消息<br>SendMessageUpwards()： 广播发送消息，但是和BroadcastMessage()是相反的，在调用自身的方法时也会向上传递，调用其父类的方法</li><li>查找组件<br>&#x2F;&#x2F;1、返回一个对应的组件，如果有多个，则只返回第一个<br><code>Cube cube = target.GetComponent\&lt;Cube&gt;();</code><br>&#x2F;&#x2F;2、返回该游戏物体上所有符合条件的组件，返回一个组件数组<br><code>Cube[] cc= target.GetComponents\&lt;Cube&gt;();</code><br>&#x2F;&#x2F;3、返回该游戏物体上的对应组件，同时返回该游戏物体的子类上对应的组件<br><code>Cube[] xx = target.GetComponentsInChildren\&lt;Cube&gt;();</code><br>&#x2F;&#x2F;4、返回该游戏物体上的对应组件，同时返回该游戏物体的父类上对应的组件<br><code>Cube[] yy = target.GetComponentsInParent\&lt;Cube&gt;();</code></li></ul><h2 id="MonoBehaviours类"><a href="#MonoBehaviours类" class="headerlink" title="MonoBehaviours类"></a>MonoBehaviours类</h2><ul><li>继承的变量成员<br><code>enabled&#123; get; set; &#125;</code> ：返回该组件是否被激活或者是被禁用，可以通过该变量来进行设置<br><code>isActiveAndEnabled&#123; get; &#125;</code> ：只能返回该组件是否激活的标志位，不能设置该变量，为只读的<br><code>tag&#123; get; set; &#125;</code> ：该组件所对应的游戏物体的标签<br><code>transform</code>：附加到此 GameObject 的 Transform。<br><code>name&#123; get; set; &#125;</code> ：该组件所对应的游戏物体的名字</li><li>Invoke（调用）等方法、变量<br>&#x2F;&#x2F;1、在等待time的时间后调用“方法1”<br><code>Invoke(方法名()，float time);</code><br>&#x2F;&#x2F;2、返回bool值，如果方法被添加到队列中，但没有被运行则返回true,如果经过一段时间后该方法被调用了则会返回false;<br><code>bool i= IsInvoking(&quot;方法1&quot;)</code> ；<br>&#x2F;&#x2F;3、 等待time时间后，会重复开始运行方法1，每秒钟运行number次。<br><code>InvokeRepeating(&quot;方法1&quot;,time,number);</code><br>&#x2F;&#x2F;4、会暂停通过Involve&#x2F;InvokeRepeating的运行，但是一般来说CancelInvoke会和InvokeRepeating组合调用。参数由自己设定<br><code>CancelInvoke();</code></li><li><strong>扩充</strong>：<ul><li>在脚本的类前添加 <code>[ExecuteInEditMode]</code>：则该脚本不用按游戏运行按钮就会开始编译，只限在编辑模式里面</li><li>在脚本的共有变量前添加 <code>[HideInInspector]</code>:则该共有变量不会在Inspector面板进行显示</li></ul></li><li>OnMousexx鼠标触发事件：<br>&#x2F;&#x2F;如果是通过Collider进行触发检测的话，则要在设置中打开允许进行射线检测。<br><code>OnMouseDown()</code>: 当鼠标按下的时候触发，按一次触发一次<br><code>OnMouseDrag()</code>: 当鼠标按住不放的时候一直触发，是每一帧进行触发<br><code>OnMouseUp()</code>: 当鼠标抬起的时候触发，只执行一次<br><code>OnMouseEnter()</code>: 当鼠标进入的时候触发，进入一次触发一次<br><code>OnMousetOver()</code>: 当鼠标在触发物体的上面时，则一直触发<br><code>OnMouseExit()</code>: 当鼠标移出的时候触发<br><code>OnMouseUpAsButton()</code>: 相当于是按钮的功能，当鼠标在同一个游戏物体上按下抬起的时候才会触发，按下与抬起不在同一个游戏上的话则不会进行触发。</li></ul><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p><code>Debug.Log(&quot;一般日志信息&quot;);</code><br><code>Debug.LogWarning(&quot;警告信息&quot;)</code><br><code>Debug.LogError(&quot;错误发生&quot;)</code></p><h2 id="Coroutine-协程"><a href="#Coroutine-协程" class="headerlink" title="Coroutine 协程"></a>Coroutine 协程</h2><p>[[笔记&#x2F;Unity&#x2F;Unity Coroutine协程|Unity Coroutine协程]]</p><ul><li>定义协程</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">IEnumerator 方法名()<br>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> ;<br>  <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">1.0f</span></span>)</span>; <br>  <span class="hljs-comment">//等待一定[[模板/时间|时间]]再运行后面的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"> <span class="hljs-comment">//通过迭代器定义一个方法</span><br><span class="hljs-function">IEnumerator <span class="hljs-title">Demo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>&#123;<br>    <span class="hljs-comment">//代码块</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> <span class="hljs-comment">//代码块</span><br>&#125;<br><br><span class="hljs-comment">//在程序种调用协程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>&#123;<br>    <span class="hljs-comment">//第一种与第二种调用方式,通过方法名与参数调用</span><br>    StartCoroutine(<span class="hljs-string">&quot;Demo&quot;</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//第三种调用方式， 通过调用方法直接调用</span><br>    StartCoroutine(Demo(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启协程<br><code>StartCoroutines(方法名());</code></li><li>开启与关闭协程<br>开启协程：<code>StartCoriutine(参数);</code><br>关闭协程：<code>StopCoroutine(参数);</code><br>其中的参数要互相对应，如果传递的是方法名，则两个方法中的参数就要是方法名<br>如果是IEnumerator的返回值，则其中两个方法发的参数就要是IEnumerator的返回值<br>&#x2F;&#x2F;1、传递方法名<br>private IEnumerator coroutine;<br>coroutine &#x3D; WaitAndPrint();<br>StartCoroutine(coroutine);<br>StopCoroutine(coroutine);<br>&#x2F;&#x2F;2、传递返回值<br>StartCoroutine(“WaitAndPrint”);<br>StopCoroutine(“WaitAndPrint”);</li><li>停止所有的协程<br><code>StopAllCoroutines();</code></li></ul><h2 id="Transform-类"><a href="#Transform-类" class="headerlink" title="Transform 类"></a>Transform 类</h2><h3 id="6-1变量"><a href="#6-1变量" class="headerlink" title="6.1变量"></a>6.1变量</h3><p>GameObject.transform.childCount：父变换具有的子项数。<br>eularAngles：以欧拉角表示的旋转（以度为单位）。<br>forward：Z轴上的位置。<br>right：X轴上的位置。<br>up：Y轴上的位置。<br>localEulerAngles：以欧拉角表示的相对于父变换旋转的旋转（以度为单位）。<br>localPosition：相对于父变换的变换位置。如果变换没有父级，则其与 Transform.position 相同。<br>localRotation：相对于父级变换旋转的变换旋转。<br>localScale：相对于父对象的变换缩放。<br>lossyScale：对象的全局缩放。（只读）<br>parent：变换的父级。更改父级将修改相对于父级的位置、缩放和旋转，但保持世界空间位置、旋转和缩放不变。<br>position：世界空间中的变换位置。<br>root：返回层级视图中最顶层的变换。（永远不返回 null；如果该变换没有父级，则返回自身。）<br>rotation：一个四元数，用于存储变换在世界空间中的旋转。</p><h3 id="6-2公共函数"><a href="#6-2公共函数" class="headerlink" title="6.2公共函数"></a>6.2公共函数</h3><p>DetachChildren：清除所有子项的父级。<br>LookAt(vector3)：旋转变换，使向前矢量指向 target 的当前位置。<br>Rotate(vector3);：使用 Transform.Rotate 以各种方式旋转游戏对象。通常以欧拉角而不是四元数提供旋转。<br>RotateAround(vector3 point,vector3 axis,vector3 angle);：将变换围绕穿过世界坐标中的 point 的 axis 旋转 angle 度。<br>SetParent(transform);：设置变换的父级。<br>SetPositionAndRotation：设置变换组件的世界空间位置和旋转。<br>Translate：根据 translation 的方向和距离移动变换。</p><h3 id="6-3继承的成员"><a href="#6-3继承的成员" class="headerlink" title="6.3继承的成员"></a>6.3继承的成员</h3><h4 id="6-3-1变量"><a href="#6-3-1变量" class="headerlink" title="6.3.1变量"></a>6.3.1变量</h4><p>gameObject：此组件附加到的游戏对象。始终将组件附加到游戏对象。<br>tag：此游戏对象的标签。<br>transform：附加到此 GameObject 的 Transform。<br>hideFlags：该对象应该隐藏、随场景一起保存还是由用户修改？<br>name：对象的名称。</p><h4 id="6-3-2公共函数"><a href="#6-3-2公共函数" class="headerlink" title="6.3.2公共函数"></a>6.3.2公共函数</h4><p>BroadcastMessage：调用此游戏对象或其任何子项中的每个 MonoBehaviour 上名为 methodName 的方法。<br>CompareTag：此游戏对象是否使用 tag 进行了标记？<br>GetComponent：如果游戏对象附加了类型为 type 的组件，则将其返回，否则返回 null。<br>GetComponentInChildren：使用深度首次搜索返回 GameObject 或其任何子项中类型为 type 的组件。<br>GetComponentInParent：返回 GameObject 或其任何父项中类型为 type 的组件。<br>GetComponents：返回 GameObject 中类型为 type 的所有组件。<br>GetComponentsInChildren：返回 GameObject 或其任何子项中类型为 type 的所有组件。<br>GetComponentsInParent：返回 GameObject 或其任何父项中类型为 type 的所有组件。<br>SendMessage：调用此游戏对象中的每个 MonoBehaviour 上名为 methodName 的方法。<br>SendMessageUpwards:调用此游戏对象中的每个 MonoBehaviour 上或此行为的每个父级上名为 methodName 的方法。<br>GetInstanceID:返回对象的实例 ID。<br>ToString:返回 GameObject 的名称。</p><h2 id="Mathf-类"><a href="#Mathf-类" class="headerlink" title="Mathf 类"></a>Mathf 类</h2><h3 id="7-1静态变量"><a href="#7-1静态变量" class="headerlink" title="7.1静态变量"></a>7.1静态变量</h3><p>E：表示自然对数的底数，它由常数 e 指定。<br>DegtoRad：度到弧度换算常量（只读）。<br>RadtoDeg：弧度到度换算常量（只读）。<br>Epsilion：微小浮点值（只读）。<br>infinity：正无穷大的表示形式（只读）。<br>NegativeInfinity：负无穷大的表示形式（只读）。<br>PI：众所周知的“3.14159265358979…”值（只读）。[[杂项&#x2F;圆周率π|圆周率π]]</p><h3 id="7-2静态函数"><a href="#7-2静态函数" class="headerlink" title="7.2静态函数"></a>7.2静态函数</h3><p>Abs() ：返回绝对值。<br>approximately：比较两个浮点值，如果它们相似，则返回 true。<br>Ceil() ：向上取整的，10.1—&gt;11&#x2F;&#x2F;CeliTolnt用法相同。<br>Clamp(value,min,max) ：如果value的值在min–max之间的话就返回value,<br>    但是如果value的值小于min,则返回min,如果value的值大于max,则返回max，<br>    一般是用在控制角色血量，当玩家的血量减少的时候，不会出现出现低于0和大于100的情况 hp&#x3D; Mathf.Clamp(hp,0,100);<br>Clamp01：将值限制在 0 与 1 之间并返回值。用于一维柏林噪声函数。<br>ClosePowerOfTwo(value) ：取得离value的2次方最近的值<br>DeltaAngle：计算两个给定角度（以度为单位给定）之间的最短差异。<br>DeltaAngke ：取得两个角度之间的最小夹角<br>Floor ：向下取整&#x2F;&#x2F;FloorTolnt用法相同。<br>InverseLerp：计算在范围 [a, b] 内生成插值 value 的线性参数 t。<br>    a 和 b 值定义线的起点和终点。Value 是 a 与 b 之间的位置。将 a 和 b 以及 value 减去 a 以获得 a’、b’ 和 value’。这会使 a’ 为零，使 b’ 和 value’ 减小。最后将 value’ 除以 b’。这可获得 InverseLerp 量。<br>    可用于进度条显示。<br>IsPowerOfTwo：如果值是 2 的幂，则返回 true。<br>Lerp：在 a 与 b 之间按 t 进行线性插值。<br>Log：返回指定的数字以指定的底数为底的对数。<br>Log10：返回指定的数字的以 10 为底的对数。<br>Max：返回两个或更多值中的最大值。<br>    &#x2F;&#x2F; public static int Max (params int[] values);<br>    Min：很明显是用来返回最小值的。<br>MoveTowards：将值 current 向 target 靠近。<br>    &#x2F;&#x2F; Mathf.MoveTowards(currStrength, maxStrength, recoveryRate * Time.deltaTime);<br>PerlinNoise：生成 2D 柏林噪声。<br>Pow(i,j) ：取得i的j次方。<br>PingPong(t,maxValue) ：类似乒乓球的来回运动，起始 值是0，通过t变量来控制值由0向maxValue移动，当t大于maxValue的时候又向0进行移动，然后就这样的来回往复运动，一般t变量用时间Time.deltatime来进行控制的。<br>Round：返回舍入为最近整数的 &#x2F;f&#x2F;。满0.5进一。<br>Sign(f)：返回f的正负号。<br>Sqrt(f)：返回 f 的平方根。</p><h2 id="Input-输入"><a href="#Input-输入" class="headerlink" title="Input 输入"></a>Input 输入</h2><p>GetKey() ：按键一直按着时触发。<br>GetKeyDown()：按键被按下那一刻进行触发。<br>GetKeyUp() :按键被按下后抬起时触发。</p><p>GetMouseButton(0&#x2F;1&#x2F;2)：1:左键 2:右键 3:中键 鼠标一直按着时触发。<br>GetMouseButtonDown()：鼠标按下那一刻触发。<br>GetMouseButtonUp()：鼠标抬起的那一刻时触发。</p><p>GetButtonDown()：键盘按钮按下那一刻触发。<br>GetButton()：键盘按钮抬起的那一刻时触发。<br>GetButtonUp()：键盘按钮抬起的那一刻时触发。</p><p>GetAxis(“虚拟轴名”)：通过按下的虚拟轴来返回-1~1之间的值，开始值是0，然后向-1&#x2F;1进行渐渐的变化，有一定的加速度。一般用来控制运动的，比如是赛车的加速运动等。<br>GetAxisRaw() ：其他的和GetAxis差不多，就是少了渐变效果，返回值只有 0 1 -1三个。</p><p>anyKeyDown{get;} ：当任何按键被按下（包括鼠标按键）时返回true。<br>anyKey{get;} ：当任何按键被按着（包括鼠标）时返回true。<br>mousePosition{get;} ：返回鼠标在屏幕上的像素坐标，【屏幕坐标】z轴衡为0的。</p><h2 id="Vector2：二维向量"><a href="#Vector2：二维向量" class="headerlink" title="Vector2：二维向量"></a>Vector2：二维向量</h2><p>&#x2F;&#x2F;public Vector2 (float x, float y);<br>magnitude{get;} ：返回向量的长度。<br>normalized{get;} ：返回这个向量长度为1的矢量，不管这个向量多长，也是返回1的矢量，只是返回值，不对原向量的值产生影响。<br>Normalize() ：无参数的，也是向量化，但是调用该方法会改变原向量值，使其的值被向量化 了。<br>ClampMagnitude() ：将一个向量限制在参数中指定的长度之间。<br>MoveToWards() ：用来做匀速的运动，由一个位置向另一个位置进行移动。<br>sqrMagnitude{get;} ： 对求向量的的长度时不进行开平方根运算了，减少性能的损耗，一般是用来比较两个向量的长度大小的。<br> 扩充：向量是结构体，为值类型，修改其中的变量的时候要整体进行修改，不能单独的进行单个变量的赋值修改。</p><h2 id="Vector3：三维变量"><a href="#Vector3：三维变量" class="headerlink" title="Vector3：三维变量"></a>Vector3：三维变量</h2><p>&#x2F;&#x2F;public Vector3 (float x, float y, float z);<br>Cross() ：插乘运算【左手法则】，通过两个向量来获得另一个向量的方向，然后进行相关的判断。<br>Project() ：投影运算。<br>Reflect() ：反射运算。<br>Slerp() ：按照角度进行插值，与lerp的按照位置信息进行插值的，一般用在炮台的旋转，使旋转的更加平滑。<br>Distence(a,b)：返回float a和b之间的距离</p><h2 id="Random随机数类"><a href="#Random随机数类" class="headerlink" title="Random随机数类"></a>Random随机数类</h2><h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><ul><li><code>InitState</code>：通过参数指定的种子随机化生成器的状态，然后再调用Range()产生随机数的时候会依据种子来进行生成，则每一次运行所生成的随机数都是一样的，是伪随机数。一般要生成的随机数不同，可以设置参数System.DataTime.Now.Ticks：通过时间戳来完成。</li><li><code>Range(min,max)</code> ：返回一个 在最小值（包括）和最大值（包括）之间的浮点型随机数（只读）。</li></ul><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><ul><li><code>insideUnitFCircle</code> ：返回一个单位圆内的随机点（只读）。</li><li><code>insideUnitSphere</code> ：返回单位球内的一个随机点（只读）。</li><li><code>onUnitSphere</code>：返回单位球表面上的一个随机点（只读）。</li><li><code>rotation</code> ：返回随机旋转。</li><li><code>rotationUniform</code> ：返回具有一致分布的随机旋转。</li><li><code>state</code> ：获取或设置随机数生成器的完整内部状态。</li><li><code>value</code> ：返回一个在[0.0,1.0]范围内的随机值（只读）。</li></ul><h3 id="System-Random"><a href="#System-Random" class="headerlink" title="System.Random"></a>System.Random</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li><code>Random();</code>&#x2F;&#x2F;使用默认种子值(系统时间的毫秒值)初始化 Random 类的新实例。</li><li><code>Random(Int32);</code>&#x2F;&#x2F;使用指定的种子值初始化 Random 类的新实例。<ul><li>由于Random在不给定随机种子的情况下是使用系统当前时间刻作为随机种子，所以在运行速度较快时，容易生成重复结果，此时可以使用该方法生成不会重复的随机种子： <code>int RandomSeed=BitConverter.ToInt32(Guid.NewGuid().ToByteArray());</code> 。</li></ul></li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><code>Next();</code>&#x2F;&#x2F;每次产生一个不同的随机正整数</li><li><code>Next(int max Value);</code>&#x2F;&#x2F;产生一个比 max Value（2,147,483,647） 小的正整数</li><li><code>Next(int min Value,int max Value);</code>&#x2F;&#x2F;产生一个 minValue~maxValue 的正整数，但不包含 maxValue</li><li><code>NextDouble();</code>&#x2F;&#x2F;产生一个0.0~1.0的浮点数</li><li><code>NextBytes(byte[]);</code>&#x2F;&#x2F;用随机数填充指定字节数的数组（0-255）</li></ul><h2 id="Quaternion-四元数"><a href="#Quaternion-四元数" class="headerlink" title="Quaternion 四元数"></a>Quaternion 四元数</h2><p>欧拉角【eylarAngles】与面板中的值对应和四元数【rotation】之间是可以进行转换的，一般欧拉角是用来让用户可以直观的看到的，而四元数是用来控制内部的运算 的。<br>eulerAngles ：将四元数转变为欧拉角<br>Euler() ：将欧拉角转变为四元数<br>LookRotation() ：让玩家通过设置四元数来进行望向敌人的旋转，将向量方向转变为四元数<br>slerp() ：在做朝向的旋转的时候，不建议使用lerp，而是建议使用slerp,使其的旋转朝向更为平滑，更加的自然</p><h2 id="Rigidbody：刚体组件，控制物体的移动"><a href="#Rigidbody：刚体组件，控制物体的移动" class="headerlink" title="Rigidbody：刚体组件，控制物体的移动"></a>Rigidbody：刚体组件，控制物体的移动</h2><p>[[笔记&#x2F;Unity&#x2F;Unity 移动物体的方式|Unity 移动物体的方式]]里有一些常见的Rigidbody用法<br>AddForce() ：添加到刚体的力。<br>AddExplosionForce() ：应用一个力到刚体来模拟爆炸效果。<br>AddForceAtPosition() ：在position位置应用force力。作为结果这个将在这个物体上应用一个扭矩和力。<br>AddRelativeForce() ：添加力到刚体。相对于它的系统坐标。<br>AddRelativeTorque(vector3) ：相对于它的局部坐标系统添加扭矩到刚体。<br>AddTorque(vector3) ：添加扭矩到刚体。<br>ClosestPointOnBounds() ：指定位置到该刚体附加的碰撞器的最近点。<br>GetPointVelocity() ：刚体在世界坐标空间，worldPoint点的速度。<br>GetRelativePointVelocity() ：相对于刚体在relativePoint点的速度。<br>IsSleeping() ：是否正休眠<br>MovePosition() ：移动位置,对position的优化，其中利用了插值运算，一般持续运动的则使用这个方法，不出现卡顿的现象.<br>MoveRotation() ：移动角度,用来控制刚体的旋转，一般不建议使用rotation,比较耗性能，建议使用MoveRotation(),然后配合Quaternion,slerp()进行使用，使其更加的平滑.<br>ResetCenterOfMass() ：重置刚体的质心。<br>ResetInertiaTensor() ：重置惯性张量值和旋转。<br>Rigidbody.position: 可以通过刚体来控制运动，在控制运动方面，使用rigibody.positon比transform.porition计算要快的多，相关的物理计算也是在刚体中计算好了，但是不建议使用这个方法来持续的控制物体的运动，不平滑，控制一两次的时候还可以使用<br>SetDensity() ：设置基于附加的碰撞器假设一个固定的密度质量。<br>Sleep() ：强制刚体休眠。<br>SweepTest() ：如果一个刚体碰到任何东西触发测试。<br>SweepTestAll() ：就像Rigidbody.SweepTest，当返回的是所有碰撞信息。<br>WakeUp() ：强制一个刚体唤醒。</p><h2 id="Collision-碰撞体"><a href="#Collision-碰撞体" class="headerlink" title="Collision 碰撞体"></a>Collision 碰撞体</h2><p>变量</p><p> articulationBody | The ArticulationBody of the collider that your GameObject collides with (Read Only).<br>body：The Rigidbody or ArticulationBody of the collider that your Component collides with (Read Only).<br>collider：我们撞击的 Collider（只读）。<br>contactCount：获取此碰撞的接触点数。<br>contacts： 物理引擎生成的接触点。应避免使用它，因为它会产生内存垃圾。改用 GetContact 或 GetContacts。<br>gameObject：您正在碰撞其碰撞体的 GameObject。（只读）。<br>impulse：为解析此碰撞而施加于该接触对的总冲量。<br>relativeVelocity：这两个碰撞对象的相对线性速度（只读）。<br>rigidbody：我们撞击的 Rigidbody（只读）。如果我们撞击的对象未附加刚体，则这是 &#x2F;null&#x2F;。<br>transform：我们撞击的对象的 Transform（只读）。</p><p>Collider.OnCollisionEnter : 碰撞体进入碰撞范围<br>Collider.OnCollisionStay : 碰撞体停留<br>Collider.OnCollisionExit : 碰撞体脱离碰撞体</p><h2 id="Camera-相机组件"><a href="#Camera-相机组件" class="headerlink" title="Camera 相机组件"></a>Camera 相机组件</h2><p>Camera是一个设备，玩家通过它看世界。<br>屏幕空间点用像素定义，屏幕的左下为(0,0);右上是（PixelWidth，pixelHeight）.Z的位置是以世界单位衡量的到相机的距离。<br>视口空间点是规范的并相对于相机的。相机的左下为（0,0）；右上是（1,1）；Z的位置是以世界为单位衡量的到相机的距离。<br>Ray ray &#x3D; cameraMain.ScreenPointToRay(Input.mousePosition); &#x2F;&#x2F;获得相机到鼠标之间的射线<br>RaycastHit hit; &#x2F;&#x2F;用来存放射线检测到的游戏物体的信息的<br>bool temp &#x3D; Physics.Raycast(ray, out hit); &#x2F;&#x2F;进行射线检测<br>CalculateObliqueMatrix() ：计算并返回倾斜接近水平的投影矩阵。<br>CopyFrom() ：使这个相机的设置与其他相机相同。<br>Render() ：手动渲染相机。<br>RenderToCubemap() ：从这个相机渲染到一个立方贴图。<br>RenderWithShader() ： 用shader替代渲染相机。<br>ResetAspect() ：恢复长宽比为屏幕的长宽比。<br>ResetProjectionMatrix() ：让投影反映正常的相机参数。<br>ResetReplacementShader() ：从相机上移除shader替换。<br>ResetWorldToCameraMatrix() ：在场景中让渲染位置反映相机的位置<br>ScreenPointToRay() ：返回一条射线从摄像机通过一个屏幕点。<br>ScreenToViewportPoint() ：从屏幕空间到视窗空间的变换位置。<br>ScreenToWorldPoint() ：从屏幕空间到世界空间的变化位置。<br>SetReplacementShader() ：使相机渲染用shader替换。<br>SetTargetBuffers() ：设置相机渲染到一个或多个RenderTextures所选择的缓冲区。<br>ViewportPointToRay() ：返回从相机出发穿过视点的一个射线。<br>ViewportToScreenPoint() ：从视口空间到屏幕空间的变换位置。<br>ViewportToWorldPoint() ：从视窗空间到世界空间的变换位置。<br>WorldToScreenPoint() ：从世界空间到屏幕空间变换位置。<br>WorldToViewportPoint() ：从世界空间到视窗空间的变换位置。</p><h2 id="Application-程序"><a href="#Application-程序" class="headerlink" title="Application 程序"></a>Application 程序</h2><p><code>OpenURL(&quot;www.baidu.com&quot;)</code>  ：打开指定的网址<br>Application.Quit()  ：退出游戏的运行<br>CapturScreenshot(“游戏截图”) ： 用来截图的，字符串为截图fileName<br><code>Application.streamingAssetsPath</code>：这个属性用于返回流数据的缓存目录，返回路径为相对路径，适合设置一些外部数据文件的路径。在Unity工程的Assets目录下起一个名为“StreamingAssets”的文件夹即可，然后用Application.streamingAssetsPath访问，这个文件夹中的资源在打包时会原封不动的打包进去，不会压缩，一般放置一些资源数据。在PC&#x2F;MAC中可实现对文件的“增删改查”等操作，但在移动端是一个只读路径。</p><h2 id="SceneManager-场景类"><a href="#SceneManager-场景类" class="headerlink" title="SceneManager 场景类"></a>SceneManager 场景类</h2><p>LoadScene()  ：加载下一个场景，一般是用在另一个场景不是太大的情况下<br>LoadSceneAsync()  ：异步加载下一个场景，返回AsyncOperation类型，里面包含了加载的信息，加载的进度条等等。可以让用户缓解等待加载场景的时间<br>sceneCount ： 获得当前加载的场景个数<br>sceneCountInBuildSettings  ：在Build面板中加载的场景个数<br>GetActiveScene() ： 获取已经加载的当前场景的信息<br>GetSceneAt(index) ： 加载index索引的场景</p><p>当加载新的场景的时候会触发下面的事件：<br>activeSceneChanged  ：当有新场景被加载的时候就会调用这个事件<br>sceneLoaded  ：当有新场景加载完成的时候就会触发这个事件<br>    &#x2F;&#x2F;事件的注册时通过加方法来进行注册的：<br>SceneManger.activeSceneChanged+&#x3D;OnAcitiveScenenChanged;</p><h2 id="Ray-射线"><a href="#Ray-射线" class="headerlink" title="Ray 射线"></a>Ray 射线</h2><p>&#x2F;&#x2F;一般射线检测要在射线检测的范围内，并且被检测物体要有Collider<br>direction ：射线的方向。<br>origin ：射线的原点。<br>Ray ：创建一条射线从origin开始，沿direction方向。<br>&#x2F;&#x2F;public Ray (Vector3 origin, Vector3 direction);<br>Raycast；检测的是射线碰撞到的第一个物体，不具有穿透性<br>RaycastAll：返回的是RaycastHit数组，具有穿透性，可以返回检测到的多个游戏物体<br>RaycastHit hit; &#x2F;&#x2F;存储射线检测到的游戏物体信息<br>PaycastHit hit;&#x2F;&#x2F;hit中存放的是射线检测的碰撞信息</p><h2 id="WWW-类"><a href="#WWW-类" class="headerlink" title="WWW 类"></a>WWW 类</h2><p>&#x2F;&#x2F;下载 是用来在网络中下载资源的<br>WWW  ：用给定的URL创建一个WWW请求。<br>GetAudioClip()  ：从下载数据，返回一个AudioClip（只读）。<br>LoadImageIntoTexture()  ：利用一个从下载数据中的图像来替换现有Texture2D。<br>LoadUnityWeb()  ：加载新的web播放器数据文件。</p><h2 id="GUI-现已废弃，使用unity自带UI-UGUI"><a href="#GUI-现已废弃，使用unity自带UI-UGUI" class="headerlink" title="GUI &#x2F;&#x2F;现已废弃，使用unity自带UI(UGUI)"></a>GUI &#x2F;&#x2F;现已废弃，使用unity自带UI(UGUI)</h2><p>静态函数<br>BeginGroup：开始一个组。必须与 EndGroup 调用配对使用。&#x2F;&#x2F;public static void BeginGroup (Rect position, string text);<br>EndGroup：结束组。<br>BeginScrollView：在 GUI 内开始一个滚动视图。&#x2F;&#x2F;public static Vector2 BeginScrollView (Rect position, Vector2 scrollPosition, Rect viewRect);<br>EndScrollView：结束使用 BeginScrollView 调用开始的滚动视图。<br>Box在 ：GUI 层上创建一个框。&#x2F;&#x2F;public static void Box (Rect position, string text);<br>BringWindowToBack：将特定窗口放置到该浮动窗口的后方。<br>BringWindowToFront：将特定窗口放置到该浮动窗口的前方。<br>Button：创建一个单击按钮。当用户点击该按钮时，立即执行一些操作。&#x2F;&#x2F;public static bool Button (Rect position, string text);<br>DragWindow：使窗口可被拖动。&#x2F;&#x2F;public static void DragWindow (Rect position);<br>FocusControl：将键盘焦点移动到某个命名控件。<br>FocusWindow：使某个窗口成为激活窗口。<br>HorizontalScrollbar：创建一个水平滚动条。滚动条是用于滚动文档的控件。大多数情况下，您需要的可能是滚动视图。<br>&#x2F;&#x2F;public static float HorizontalScrollbar (Rect position, float value, float size, float leftValue, float rightValue);<br>HorizontalSlider：用户可以拖动的水平滑动条，用于在最小值和最大值之间更改某值。<br>&#x2F;&#x2F;public static float HorizontalSlider (Rect position, float value, float leftValue, float rightValue);<br>Label：在屏幕上创建一个文本或纹理标签。&#x2F;&#x2F;public static void Label (Rect position, string text);<br>ModalWindow：显示一个模态窗口。<br>ScrollTo：滚动包含的所有滚动视图，让它们尝试使 position 可见。&#x2F;&#x2F;public static void ScrollTo (Rect position);<br>SelectionGrid：创建一个按钮网格。&#x2F;&#x2F;public static int SelectionGrid (Rect position, int selected, string[] texts, int xCount);<br>TextArea：创建一个可供用户编辑字符串的多行文本区域。&#x2F;&#x2F;public static string TextArea (Rect position, string text);<br>TextField：创建一个可供用户编辑字符串的单行文本字段。&#x2F;&#x2F;public static string TextField (Rect position, string text);<br>Toggle：创建一个打开&#x2F;关闭的开关按钮。&#x2F;&#x2F;public static bool Toggle (Rect position, bool value, string text);<br>Toolbar：创建一个工具栏。&#x2F;&#x2F;public static int Toolbar (Rect position, int selected, string[] texts);<br>VerticalScrollbar：创建一个垂直滚动条。滚动条是用于滚动文档的控件。大多数情况下，您需要的可能是滚动视图。<br>&#x2F;&#x2F;public static float VerticalScrollbar (Rect position, float value, float size, float topValue, float bottomValue);<br>VerticalSlider：用户可以拖动的垂直滑动条，用于在最小值和最大值之间更改某值。<br>&#x2F;&#x2F;public static float VerticalSlider (Rect position, float value, float topValue, float bottomValue);<br>Window：创建一个弹出窗口。&#x2F;&#x2F;public static Rect Window (int id, Rect clientRect, GUI.WindowFunction func, string text);</p><h2 id="Rect-矩形"><a href="#Rect-矩形" class="headerlink" title="Rect 矩形"></a>Rect 矩形</h2><p>构造矩形。&#x2F;&#x2F;public Rect (float x, float y, float width, float height);<br>通过最小&#x2F;最大坐标值创建矩形。&#x2F;&#x2F;public static Rect MinMaxRect (float xmin, float ymin, float xmax, float ymax);</p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>匈牙利记号法</title>
    <link href="/2024/02/24/%E5%8C%88%E7%89%99%E5%88%A9%E8%AE%B0%E5%8F%B7%E6%B3%95/"/>
    <url>/2024/02/24/%E5%8C%88%E7%89%99%E5%88%A9%E8%AE%B0%E5%8F%B7%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>有关项目的全局变量用 <code>g_</code> 开始，类的成员变量用 <code>m_</code> ，局部变量若函数较大可考虑用 <code>l_</code> 说明其是局部变量</p><table><thead><tr><th>前缀</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>a_</td><td>Array</td><td>数组</td></tr><tr><td>b_</td><td>bool(int)</td><td>布尔（整数）</td></tr><tr><td>by_</td><td>Unsigned Char(byte)</td><td>无符号字符（字节）</td></tr><tr><td>c</td><td>char</td><td>字符（字节）</td></tr><tr><td>cb</td><td>Count of Bytes</td><td>字节数</td></tr><tr><td>cr</td><td>Color Reference Value</td><td>颜色（参考）值</td></tr><tr><td>cx</td><td>Count of X(short)</td><td>x的集合（短整数）</td></tr><tr><td>f</td><td>Flags(Usually mutiple bit values)</td><td>标志（一般是多位数的数值）</td></tr><tr><td>fn</td><td>Function</td><td>函数</td></tr><tr><td>g_</td><td>global</td><td>全局</td></tr><tr><td>h</td><td>Handle</td><td>句柄</td></tr><tr><td>i</td><td>Integer</td><td>整数</td></tr><tr><td>l</td><td>long</td><td>长整数</td></tr><tr><td>lp</td><td>Long Pointer</td><td>长指针</td></tr><tr><td><strong>m_</strong></td><td>Data Menber of a Class</td><td><strong>一个类的数据成员</strong></td></tr><tr><td>n</td><td>short Integer</td><td>短整数</td></tr><tr><td>p</td><td>Pointer</td><td>指针</td></tr><tr><td>s</td><td>String</td><td>字符串</td></tr><tr><td>sz</td><td>Zero Terminated String</td><td>以零结束的字符串</td></tr><tr><td>tm</td><td>Text Metric</td><td>文本规则</td></tr><tr><td>u</td><td>Unsigned Integer</td><td>无符号整数</td></tr><tr><td>ul</td><td>Unsigned Long(Ulong)</td><td>无符号长整数</td></tr><tr><td>w</td><td>WORD(Unsigned Short)</td><td>无符号短整数</td></tr><tr><td>x,y</td><td>x,y Coordinates(Short)</td><td>坐标值（短整数）</td></tr><tr><td>v</td><td>Void</td><td>空</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>驼峰命名法</title>
    <link href="/2024/02/24/%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E6%B3%95/"/>
    <url>/2024/02/24/%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>简介：混合使用大小写字母来构成变量和函数的名称。<br>意义：提高代码的可读性，便于项目开发和维护。</p><ul><li>大驼峰法：<ul><li>规则：<strong>第一个单词和其他单词的首字母均大写。</strong></li><li>用于：<em><strong>类名</strong></em>、<em><strong>函数名</strong></em>、<em><strong>属性</strong></em>、<em><strong>命名空间</strong></em>。</li></ul></li><li>小驼峰法：<ul><li>规则：<strong>除第一个单词外，其他单词首字母均大写。</strong></li><li>用于：<em><strong>变量</strong></em>。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Front-matter</title>
    <link href="/2024/02/21/Hexo-Front-matter/"/>
    <url>/2024/02/21/Hexo-Front-matter/</url>
    
    <content type="html"><![CDATA[<h2 id="可用的文章属性"><a href="#可用的文章属性" class="headerlink" title="可用的文章属性"></a>可用的文章属性</h2><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>config.default_layout</td></tr><tr><td>title</td><td>标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>update</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启文章的评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章的永久链接</td><td>null</td></tr><tr><td>excerpt</td><td>纯文本的页面摘要</td><td></td></tr><tr><td>disableNunjucks</td><td>禁用Nunjucks标签 <code>&#123;&#123;&#125;&#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code>和标签插件的渲染功能</td><td>false</td></tr><tr><td>lang</td><td>设置语言以覆盖自动检测</td><td></td></tr><tr><td>published</td><td>文章是否发布</td><td>post下的文章为true，draft下的文章给你为false</td></tr></tbody></table><h2 id="典型的分类和标签形式如下"><a href="#典型的分类和标签形式如下" class="headerlink" title="典型的分类和标签形式如下"></a>典型的分类和标签形式如下</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">diary</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">PS3</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Games</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>死循环</title>
    <link href="/2024/02/21/%E6%AD%BB%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/02/21/%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h1><h2 id="以无限循环的形式实现监听守护"><a href="#以无限循环的形式实现监听守护" class="headerlink" title="以无限循环的形式实现监听守护"></a>以无限循环的形式实现监听守护</h2><p><code>for (; ; )</code> 死循环（Infinite Loop）</p><p>这种写法通常用于需要持续运行或监听某些事件的场景，例如服务器端的消息监听、守护线程的执行等。在使用死循环时，需要谨慎处理循环体内部的逻辑，确保循环能够在适当的时候退出，避免陷入无限循环造成系统资源的浪费或程序无法正常终止。要注意的是，在某些情况下，编译器或代码静态分析工具可能会提示无限循环的警告或错误，因为这种写法可能会引起程序不可达的问题。因此，在使用死循环时，需要确保循环终止的条件是正确设置和处理的。在循环内使用 <code>continue;</code> 和 <code>break;</code> 控制循环条件。类似于 <code>While(true)</code> 。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>判断浮点数是否相等</title>
    <link href="/2024/02/21/%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
    <url>/2024/02/21/%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h1 id="关于浮点数判断时的误差问题"><a href="#关于浮点数判断时的误差问题" class="headerlink" title="关于浮点数判断时的误差问题"></a>关于浮点数判断时的误差问题</h1><p>在做关于浮点数的计算时，不要使用 <code>==</code> 来做判断，因为无法避免误差。</p><p>不要使用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> testresult:<span class="hljs-built_in">float</span> = <span class="hljs-number">1</span> - <span class="hljs-number">0.8f</span>;<br><span class="hljs-keyword">if</span>(testresult == <span class="hljs-number">0.2f</span>)<br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;equal&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;not equal&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>而是：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">WithinErroeMargin</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> left, <span class="hljs-built_in">float</span> right</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> Mathf.Abs.(f: left = right) &lt;= <span class="hljs-number">0.0001f</span>;<span class="hljs-comment">//误差范围0.0001f，根据使用场景而定</span><br>&#125;<br><span class="hljs-keyword">if</span>(WithinErrorMargin(left: testresult, right: <span class="hljs-number">0.2f</span>))<br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;WithinErrorMargin equal&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;WithinErrorMargin not equal&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当需要浮点数转换时，尽量避免强制转换产生的精度丢失，常用的库有：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">bool</span> equal = Mathf.Approximately(<span class="hljs-number">1.0f</span>, <span class="hljs-number">10.0f</span> / <span class="hljs-number">10.0f</span>);<br><span class="hljs-comment">//该判断的误差范围接近无穷小</span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Mathf.RoundToInt(f:<span class="hljs-number">1.9f</span>);<span class="hljs-comment">//2 返回最接近1.9的整数 四舍五入 </span><br>Mathf.FloorToInt(f:<span class="hljs-number">1.9f</span>);<span class="hljs-comment">//1 返回小于等于1.9的最大整数 向下取整</span><br>Mathf.CeliToInt(f:<span class="hljs-number">1.9f</span>);<span class="hljs-comment">//2 返回大于等于1.9的最小整数 向上取整</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高内聚低耦合</title>
    <link href="/2024/02/21/%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    <url>/2024/02/21/%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h1><h2 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h2><p>高内聚是另外一个评判软件设计质量的标准。内聚更为专业的说法叫做功能内聚，是对系统中元素职责的相关性和集中度的量度。如果元素有高度的相关职责，除了这些职责在没有其他的工作，那么该元素就有高内聚。<br>内聚指的是模块内部的功能，最强的就是功能不能拆分，也就是原子化。</p><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><p>这就好像，如果我是一个项目经理，我的职责是监控和协调我的项目各个阶段的工作。当我的项目进入需求分析阶段，我会请求需求分析员来完成；当我的项目进入开发阶段，我会请求软件开发人员来完成；当我的项目需要测试的时候，我会请求测试人员。。。。。。如果我参与了开发，我就不是一个高内聚的元素，因为开发不是我的职责。</p><h3 id="为什么要高内聚"><a href="#为什么要高内聚" class="headerlink" title="为什么要高内聚"></a>为什么要高内聚</h3><ul><li>可读性</li><li>复用性</li><li>可维护性和易变更性</li></ul><h2 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h2><p>耦合就是元素与元素之间的连接，感知和依赖量度。这里说的元素即是功能，对象，系统，子系统。模块。</p><h3 id="例如-1"><a href="#例如-1" class="headerlink" title="例如"></a>例如</h3><p>现在有方法A和方法B<br>我们在A元素去调用B元素，当B元素有问题或者不存在的时候，A元素就不能正常的工作，那么就说元素A和元素B耦合</p><h3 id="耦合带来的问题"><a href="#耦合带来的问题" class="headerlink" title="耦合带来的问题"></a>耦合带来的问题</h3><p>当元素B变更或者不存在时，都将影响元素A的正常运作，影响系统的可维护性和易变更性。同时元素A只能运行在元素B中，这也大大的降低了A元素的可复用性。正因为耦合的种种弊端，我们才需要在软件设计上追求低耦合</p><h3 id="如何实现低耦合"><a href="#如何实现低耦合" class="headerlink" title="如何实现低耦合"></a>如何实现低耦合</h3><ul><li>元素A不能过度依赖元素B</li><li>合理的职责划分：让系统中的对象各司其职，不仅是提高内聚的要求，同时也可以有效地降低耦合</li><li>使用接口而不是继承：我们不难发现。继承就是一种耦合，假如子类A继承了父类B，不论是直接继承或者间接继承，一但父类B不存在或者发生任何变更，都将导致子类A不得不修改或者重写。假如父类B的子类数十上百的，这就是灾难性的变更。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>建站纪念</title>
    <link href="/2024/02/21/%E5%BB%BA%E7%AB%99%E7%BA%AA%E5%BF%B5/"/>
    <url>/2024/02/21/%E5%BB%BA%E7%AB%99%E7%BA%AA%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="建站纪念"><a href="#建站纪念" class="headerlink" title="建站纪念"></a>建站纪念</h1><p>从昨天的半夜一置到凌晨5点，折腾了半天终于用hexo把hithub个人主页给弄出来了。<br>之前用github默认的jekyll模板建过主页，导致hexo建站push不上去，git成功但是主页没变。<br>之后直接删库，重新建了一个username.github.io，又重新push了一次，这次成功了，而且也不用像jekyll那样，DeployAction之后还得等几分钟。<br>只要hexo generate之后hexo deploy上去就更新完成了。确实是非常方便，而且我用了fluid主题，文档非常丰富，之后肯定还会继续更新和丰富博客。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/21/hello-world/"/>
    <url>/2024/02/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-创建新post"><a href="#Create-a-new-post-创建新post" class="headerlink" title="Create a new post 创建新post"></a>Create a new post 创建新post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server-运行服务"><a href="#Run-server-运行服务" class="headerlink" title="Run server 运行服务"></a>Run server 运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files-生成固定文档"><a href="#Generate-static-files-生成固定文档" class="headerlink" title="Generate static files 生成固定文档"></a>Generate static files 生成固定文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites-部署到远程站点"><a href="#Deploy-to-remote-sites-部署到远程站点" class="headerlink" title="Deploy to remote sites 部署到远程站点"></a>Deploy to remote sites 部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
