<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Unity 常用API</title>
    <link href="/2024/02/24/Unity-%E5%B8%B8%E7%94%A8API/"/>
    <url>/2024/02/24/Unity-%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h2 id="Event-Function-事件函数-即生命周期函数"><a href="#Event-Function-事件函数-即生命周期函数" class="headerlink" title="Event Function:事件函数 &#x2F;&#x2F;即生命周期函数"></a>Event Function:事件函数 &#x2F;&#x2F;即生命周期函数</h2><p><code>Awake()</code> : 始终在任何 Start 函数之前（开始渲染之前）并在实例化预制件之后（一些manager脚本、网络等）调用此函数。如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。<br><code>OnEnable()</code> : 当将物体的SetActive设置为true时就会自动调用调用该方法。<br><code>Awake()</code>、<code>Start()</code> : 都是在游戏物体初始化运行一次，但是Awake的运行顺序高于Start的，并且只要脚本中存在Awake方法，则无论是否挂载了该脚本都会执行该方法。<br><code>Start()</code> :在游戏初始化时会执行一次，不是很紧急的初始化，一般放在Start里面来做。仅在Update函数第一次被调用前调用。<br><code>Fixed Update()</code> : 会按固定时间差重复执行，用在力学更新效果中。执行在Update之前。<br><code>Update()</code> : 每一帧都会运行这个方法，是用于帧更新的主要函数。<br><code>LateUpdate()</code> : 晚于Update的运行顺序，但是FPS和Update是一样的，一般人物的移动放在Update中，而摄像机的跟进变化放到FixedUpdate中。确保两个独立。<br><code>OnDisable()</code> : 物体被禁用时调用。<br><code>OnDestory()</code> : 当对象被销毁或关闭游戏时调用。<br><code>Reset()</code> : 被附加脚本时、在游戏物体的组件上按Reset时会触发该事件函数，调用 Reset 可以在脚本首次附加到对象时以及使用 ReSet 命令时初始化脚本的属性。</p><h2 id="Attribute-属性"><a href="#Attribute-属性" class="headerlink" title="Attribute 属性"></a>Attribute 属性</h2><p><code>[serializeField]</code>：将私有类型和保护类型的变量可视化到面板上<br><code>[System.serializedField]</code>：将自定义类型的变量可视化到面板上<br><code>[HideIninspector]</code>：在面板上隐藏公共变量<br><code>[Header(&quot;分组说明&quot;)]</code>：将公共变量进行分组<br><code>[Tooltip(&quot;提示信息&quot;)]</code>：鼠标悬浮在该变量上时显示说明信息<br><code>[Range(float min,float max)]</code>：通过拖动条的方式来控制范围<br><code>[contexMenuItem(string 变量名,方法名())]</code>：停在可视化变量上时显示方法，并可以点击调用，需要是无参数无返回值的方法<br><code>[contexMenu(&quot;方法名&quot;)]</code>：只为调试，右键选择方法执行<br><code>[Multline(n)]</code>：将字符串设置可见的n行<br><code>[TextArea(min,max)]</code>：添加滚动条来查看设置的文本区<br><code>[DisallowMulipleComponment]</code>：不允许挂载多重脚本</p><h2 id="Directory-路径"><a href="#Directory-路径" class="headerlink" title="Directory 路径"></a>Directory 路径</h2><h2 id="Corsor-鼠标指针"><a href="#Corsor-鼠标指针" class="headerlink" title="Corsor 鼠标指针"></a>Corsor 鼠标指针</h2><ul><li>CursorLockMode.Confined : 将光标限制在游戏窗体中</li><li>CursorLockMode.Locked : 光标锁定到视图的中心</li><li>CuesorLockMode.None : 无规定</li><li>Cursor.visible : 光标可见性</li><li>Input.mousePosition : 当前鼠标在像素坐标中的位置</li></ul><h2 id="Time-时间类函数"><a href="#Time-时间类函数" class="headerlink" title="Time 时间类函数"></a>Time 时间类函数</h2><ul><li>静态变量<ul><li>Time.time ：表示从游戏开发到现在的时间，会随着游戏的暂停而停止计算。</li><li>Time.timeSinceLevelLoad ： 表示从当前Scene开始到目前为止的时间，也会随着暂停操作而停止。</li><li>Time.deltaTime ： 表示从上一帧到当前帧时间，以秒为单位。【一般用来控制角色、动画的运动】</li><li>Time.fixedTime ： 表示以秒计游戏开始的时间，固定时间以定期间隔更新（相当于fixedDeltaTime）直到达到time属性。</li><li>Time.fixedDeltaTime ： 表示以秒计间隔，在物理和其他固定帧率进行更新，在Edit-&gt;ProjectSettings-&gt;Time的Fixed Timestep可以自行设置。</li><li>Time.SmoothDeltaTime： 表示一个平稳的deltaTime，根据前 N帧的时间加权平均的值。</li><li>Time.timeScale： 时间缩放，默认值为1，若设置 &lt; 1，表示时间减慢，若设置 &gt; 1,表示时间加快，可以用来加速和减速游戏，回放等、非常有用。如果游戏中控制运动的都是使用了Time.deltatime的话，则可以通过设置Time.timeScale&#x3D; 0来暂停其运动等。</li><li>Time.frameCount ： 总帧数</li><li>Time.realtimeSinceStartup  ： 表示自游戏开始后的总时间，即使暂停也会不断的增加。【一般用作性能测试】</li><li>Time.captureFramerate ： 表示设置每秒的帧率，然后不考虑真实时间。</li><li>Time.unscaledDeltaTime ： 以秒计算，完成最后一帧的时间 不考虑timescale时候与deltaTime相同，若timescale被设置，则无效。</li><li>Time.unscaledTime： 从游戏开始到现在所用的时间 不考虑timescale时候与time相同，若timescale被设置，则无效。</li></ul></li></ul><h2 id="GameObject-游戏物体"><a href="#GameObject-游戏物体" class="headerlink" title="GameObject 游戏物体"></a>GameObject 游戏物体</h2><ul><li>创建游戏物体<ul><li>创建空的游戏对象<br><code>new GameObejct(&quot;name&quot;);</code></li></ul></li><li>实例化创建游戏对象<br><code>public static Object Instantiate (Prefab name);</code>&#x2F;&#x2F;实例化一个预制件<br><code>public static Object Instantiate (Prefab name,Vector3 position,Quaternion rotation,Transform parent);</code>&#x2F;&#x2F;并且赋值它的位置、旋转、父物体transform<br>&#x2F;&#x2F;根据Prefab或者是另外一个游戏物体来创建（克隆Colon），可以实例粒子、等其他的游戏物体，常用<br>通过预制体实例化还可以使用 <code>Resources.Load&lt;GameObject&gt;(&quot;PrefabName&quot;);</code> 不区分大小写</li><li>创建基本的物体<br><code>CreatPrimitive(PrimitiveType);</code></li><li>添加组件<br><code>new GameObject(name);</code><br><code>name.AddComponent&lt;组件名&gt;();</code><br><code>name.AddComponent&lt;脚本名&gt;();</code></li><li>属性和变量<br><code>object.name</code>：对象的名称。<br><code>GameObject.SetActive(false/true)</code> ：通过参数的控制来设置其游戏物体的激活状态，true为激活状态，反之为取消激活状态。<br><code>GameObject.activeInHierarchy</code>： 游戏物体是否处于激活状态，与父类有关，父类被取消激活，则子类也是取消激活的。<br><code>GameObject.activeSelf</code> ： 自身的激活状态，与父类无关，只与自身有关。<br><code>GameObject.tag</code>： 游戏物体的tag标签，具体的由程序员自定义设置。</li><li>静态函数,共有方法，变量<br><code>Destroy()</code> ：删除游戏物体，但是不会立马在unity中删除，而是会先进行回收，等确定没对象使用的时候，在进行删除<br><code>DontDestroyOnLoad()</code> ： 当加载新的场景的时候，不删除这个场景中的某个游戏物体<br><code>FindObjectOfType\&lt;T&gt;()</code> ：通过类型T来进行查找对象，返回的是一个对象<br><code>FindObjectsOfType\&lt;T&gt;()</code>：通过类型T来进行查找对象，返回类型为Type的所有活动加载对象的列表。<br><code>FindGameObjectWithTag()</code> ：返回标记的Tag活动游戏对象。<br><code>FindGameObjectsWithTag()</code> ：返回标记的Tag活动游戏对象列表。如果没有GameObject(游戏物体)返回空数组</li><li>消息发送<br><code>BroadcastMessage()</code> ：广播发送消息，则该物体上对应的方法会被调用，同时这个游戏物体上的子物体上对应的方法也会被调用的<br><code>SendMessage() </code>：发送消息，只会对这个游戏物体中脚本上的方法发送消息<br>SendMessageUpwards()： 广播发送消息，但是和BroadcastMessage()是相反的，在调用自身的方法时也会向上传递，调用其父类的方法</li><li>查找组件<br>&#x2F;&#x2F;1、返回一个对应的组件，如果有多个，则只返回第一个<br><code>Cube cube = target.GetComponent\&lt;Cube&gt;();</code><br>&#x2F;&#x2F;2、返回该游戏物体上所有符合条件的组件，返回一个组件数组<br><code>Cube[] cc= target.GetComponents\&lt;Cube&gt;();</code><br>&#x2F;&#x2F;3、返回该游戏物体上的对应组件，同时返回该游戏物体的子类上对应的组件<br><code>Cube[] xx = target.GetComponentsInChildren\&lt;Cube&gt;();</code><br>&#x2F;&#x2F;4、返回该游戏物体上的对应组件，同时返回该游戏物体的父类上对应的组件<br><code>Cube[] yy = target.GetComponentsInParent\&lt;Cube&gt;();</code></li></ul><h2 id="MonoBehaviours类"><a href="#MonoBehaviours类" class="headerlink" title="MonoBehaviours类"></a>MonoBehaviours类</h2><ul><li>继承的变量成员<br><code>enabled&#123; get; set; &#125;</code> ：返回该组件是否被激活或者是被禁用，可以通过该变量来进行设置<br><code>isActiveAndEnabled&#123; get; &#125;</code> ：只能返回该组件是否激活的标志位，不能设置该变量，为只读的<br><code>tag&#123; get; set; &#125;</code> ：该组件所对应的游戏物体的标签<br><code>transform</code>：附加到此 GameObject 的 Transform。<br><code>name&#123; get; set; &#125;</code> ：该组件所对应的游戏物体的名字</li><li>Invoke（调用）等方法、变量<br>&#x2F;&#x2F;1、在等待time的时间后调用“方法1”<br><code>Invoke(方法名()，float time);</code><br>&#x2F;&#x2F;2、返回bool值，如果方法被添加到队列中，但没有被运行则返回true,如果经过一段时间后该方法被调用了则会返回false;<br><code>bool i= IsInvoking(&quot;方法1&quot;)</code> ；<br>&#x2F;&#x2F;3、 等待time时间后，会重复开始运行方法1，每秒钟运行number次。<br><code>InvokeRepeating(&quot;方法1&quot;,time,number);</code><br>&#x2F;&#x2F;4、会暂停通过Involve&#x2F;InvokeRepeating的运行，但是一般来说CancelInvoke会和InvokeRepeating组合调用。参数由自己设定<br><code>CancelInvoke();</code></li><li><strong>扩充</strong>：<ul><li>在脚本的类前添加 <code>[ExecuteInEditMode]</code>：则该脚本不用按游戏运行按钮就会开始编译，只限在编辑模式里面</li><li>在脚本的共有变量前添加 <code>[HideInInspector]</code>:则该共有变量不会在Inspector面板进行显示</li></ul></li><li>OnMousexx鼠标触发事件：<br>&#x2F;&#x2F;如果是通过Collider进行触发检测的话，则要在设置中打开允许进行射线检测。<br><code>OnMouseDown()</code>: 当鼠标按下的时候触发，按一次触发一次<br><code>OnMouseDrag()</code>: 当鼠标按住不放的时候一直触发，是每一帧进行触发<br><code>OnMouseUp()</code>: 当鼠标抬起的时候触发，只执行一次<br><code>OnMouseEnter()</code>: 当鼠标进入的时候触发，进入一次触发一次<br><code>OnMousetOver()</code>: 当鼠标在触发物体的上面时，则一直触发<br><code>OnMouseExit()</code>: 当鼠标移出的时候触发<br><code>OnMouseUpAsButton()</code>: 相当于是按钮的功能，当鼠标在同一个游戏物体上按下抬起的时候才会触发，按下与抬起不在同一个游戏上的话则不会进行触发。</li></ul><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p><code>Debug.Log(&quot;一般日志信息&quot;);</code><br><code>Debug.LogWarning(&quot;警告信息&quot;)</code><br><code>Debug.LogError(&quot;错误发生&quot;)</code></p><h2 id="Coroutine-协程"><a href="#Coroutine-协程" class="headerlink" title="Coroutine 协程"></a>Coroutine 协程</h2><p>[[笔记&#x2F;Unity&#x2F;Unity Coroutine协程|Unity Coroutine协程]]</p><ul><li>定义协程</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">IEnumerator 方法名()<br>&#123;<br><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> ;<br><span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">1.0f</span></span>)</span>; <br><span class="hljs-comment">//等待一定[[模板/时间|时间]]再运行后面的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"> <span class="hljs-comment">//通过迭代器定义一个方法</span><br><span class="hljs-function">IEnumerator <span class="hljs-title">Demo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>&#123;<br>    <span class="hljs-comment">//代码块</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> <span class="hljs-comment">//代码块</span><br>&#125;<br><br><span class="hljs-comment">//在程序种调用协程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>&#123;<br>    <span class="hljs-comment">//第一种与第二种调用方式,通过方法名与参数调用</span><br>    StartCoroutine(<span class="hljs-string">&quot;Demo&quot;</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//第三种调用方式， 通过调用方法直接调用</span><br>    StartCoroutine(Demo(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启协程<br><code>StartCoroutines(方法名());</code></li><li>开启与关闭协程<br>开启协程：<code>StartCoriutine(参数);</code><br>关闭协程：<code>StopCoroutine(参数);</code><br>其中的参数要互相对应，如果传递的是方法名，则两个方法中的参数就要是方法名<br>如果是IEnumerator的返回值，则其中两个方法发的参数就要是IEnumerator的返回值<br>&#x2F;&#x2F;1、传递方法名<br>private IEnumerator coroutine;<br>coroutine &#x3D; WaitAndPrint();<br>StartCoroutine(coroutine);<br>StopCoroutine(coroutine);<br>&#x2F;&#x2F;2、传递返回值<br>StartCoroutine(“WaitAndPrint”);<br>StopCoroutine(“WaitAndPrint”);</li><li>停止所有的协程<br><code>StopAllCoroutines();</code></li></ul><h2 id="Transform-类"><a href="#Transform-类" class="headerlink" title="Transform 类"></a>Transform 类</h2><h3 id="6-1变量"><a href="#6-1变量" class="headerlink" title="6.1变量"></a>6.1变量</h3><p>GameObject.transform.childCount：父变换具有的子项数。<br>eularAngles：以欧拉角表示的旋转（以度为单位）。<br>forward：Z轴上的位置。<br>right：X轴上的位置。<br>up：Y轴上的位置。<br>localEulerAngles：以欧拉角表示的相对于父变换旋转的旋转（以度为单位）。<br>localPosition：相对于父变换的变换位置。如果变换没有父级，则其与 Transform.position 相同。<br>localRotation：相对于父级变换旋转的变换旋转。<br>localScale：相对于父对象的变换缩放。<br>lossyScale：对象的全局缩放。（只读）<br>parent：变换的父级。更改父级将修改相对于父级的位置、缩放和旋转，但保持世界空间位置、旋转和缩放不变。<br>position：世界空间中的变换位置。<br>root：返回层级视图中最顶层的变换。（永远不返回 null；如果该变换没有父级，则返回自身。）<br>rotation：一个四元数，用于存储变换在世界空间中的旋转。</p><h3 id="6-2公共函数"><a href="#6-2公共函数" class="headerlink" title="6.2公共函数"></a>6.2公共函数</h3><p>DetachChildren：清除所有子项的父级。<br>LookAt(vector3)：旋转变换，使向前矢量指向 target 的当前位置。<br>Rotate(vector3);：使用 Transform.Rotate 以各种方式旋转游戏对象。通常以欧拉角而不是四元数提供旋转。<br>RotateAround(vector3 point,vector3 axis,vector3 angle);：将变换围绕穿过世界坐标中的 point 的 axis 旋转 angle 度。<br>SetParent(transform);：设置变换的父级。<br>SetPositionAndRotation：设置变换组件的世界空间位置和旋转。<br>Translate：根据 translation 的方向和距离移动变换。</p><h3 id="6-3继承的成员"><a href="#6-3继承的成员" class="headerlink" title="6.3继承的成员"></a>6.3继承的成员</h3><h4 id="6-3-1变量"><a href="#6-3-1变量" class="headerlink" title="6.3.1变量"></a>6.3.1变量</h4><p>gameObject：此组件附加到的游戏对象。始终将组件附加到游戏对象。<br>tag：此游戏对象的标签。<br>transform：附加到此 GameObject 的 Transform。<br>hideFlags：该对象应该隐藏、随场景一起保存还是由用户修改？<br>name：对象的名称。</p><h4 id="6-3-2公共函数"><a href="#6-3-2公共函数" class="headerlink" title="6.3.2公共函数"></a>6.3.2公共函数</h4><p>BroadcastMessage：调用此游戏对象或其任何子项中的每个 MonoBehaviour 上名为 methodName 的方法。<br>CompareTag：此游戏对象是否使用 tag 进行了标记？<br>GetComponent：如果游戏对象附加了类型为 type 的组件，则将其返回，否则返回 null。<br>GetComponentInChildren：使用深度首次搜索返回 GameObject 或其任何子项中类型为 type 的组件。<br>GetComponentInParent：返回 GameObject 或其任何父项中类型为 type 的组件。<br>GetComponents：返回 GameObject 中类型为 type 的所有组件。<br>GetComponentsInChildren：返回 GameObject 或其任何子项中类型为 type 的所有组件。<br>GetComponentsInParent：返回 GameObject 或其任何父项中类型为 type 的所有组件。<br>SendMessage：调用此游戏对象中的每个 MonoBehaviour 上名为 methodName 的方法。<br>SendMessageUpwards:调用此游戏对象中的每个 MonoBehaviour 上或此行为的每个父级上名为 methodName 的方法。<br>GetInstanceID:返回对象的实例 ID。<br>ToString:返回 GameObject 的名称。</p><h2 id="Mathf-类"><a href="#Mathf-类" class="headerlink" title="Mathf 类"></a>Mathf 类</h2><h3 id="7-1静态变量"><a href="#7-1静态变量" class="headerlink" title="7.1静态变量"></a>7.1静态变量</h3><p>E：表示自然对数的底数，它由常数 e 指定。<br>DegtoRad：度到弧度换算常量（只读）。<br>RadtoDeg：弧度到度换算常量（只读）。<br>Epsilion：微小浮点值（只读）。<br>infinity：正无穷大的表示形式（只读）。<br>NegativeInfinity：负无穷大的表示形式（只读）。<br>PI：众所周知的“3.14159265358979…”值（只读）。[[杂项&#x2F;圆周率π|圆周率π]]</p><h3 id="7-2静态函数"><a href="#7-2静态函数" class="headerlink" title="7.2静态函数"></a>7.2静态函数</h3><p>Abs() ：返回绝对值。<br>approximately：比较两个浮点值，如果它们相似，则返回 true。<br>Ceil() ：向上取整的，10.1—&gt;11&#x2F;&#x2F;CeliTolnt用法相同。<br>Clamp(value,min,max) ：如果value的值在min–max之间的话就返回value,<br>    但是如果value的值小于min,则返回min,如果value的值大于max,则返回max，<br>    一般是用在控制角色血量，当玩家的血量减少的时候，不会出现出现低于0和大于100的情况 hp&#x3D; Mathf.Clamp(hp,0,100);<br>Clamp01：将值限制在 0 与 1 之间并返回值。用于一维柏林噪声函数。<br>ClosePowerOfTwo(value) ：取得离value的2次方最近的值<br>DeltaAngle：计算两个给定角度（以度为单位给定）之间的最短差异。<br>DeltaAngke ：取得两个角度之间的最小夹角<br>Floor ：向下取整&#x2F;&#x2F;FloorTolnt用法相同。<br>InverseLerp：计算在范围 [a, b] 内生成插值 value 的线性参数 t。<br>    a 和 b 值定义线的起点和终点。Value 是 a 与 b 之间的位置。将 a 和 b 以及 value 减去 a 以获得 a’、b’ 和 value’。这会使 a’ 为零，使 b’ 和 value’ 减小。最后将 value’ 除以 b’。这可获得 InverseLerp 量。<br>    可用于进度条显示。<br>IsPowerOfTwo：如果值是 2 的幂，则返回 true。<br>Lerp：在 a 与 b 之间按 t 进行线性插值。<br>Log：返回指定的数字以指定的底数为底的对数。<br>Log10：返回指定的数字的以 10 为底的对数。<br>Max：返回两个或更多值中的最大值。<br>    &#x2F;&#x2F; public static int Max (params int[] values);<br>    Min：很明显是用来返回最小值的。<br>MoveTowards：将值 current 向 target 靠近。<br>    &#x2F;&#x2F; Mathf.MoveTowards(currStrength, maxStrength, recoveryRate * Time.deltaTime);<br>PerlinNoise：生成 2D 柏林噪声。<br>Pow(i,j) ：取得i的j次方。<br>PingPong(t,maxValue) ：类似乒乓球的来回运动，起始 值是0，通过t变量来控制值由0向maxValue移动，当t大于maxValue的时候又向0进行移动，然后就这样的来回往复运动，一般t变量用时间Time.deltatime来进行控制的。<br>Round：返回舍入为最近整数的 &#x2F;f&#x2F;。满0.5进一。<br>Sign(f)：返回f的正负号。<br>Sqrt(f)：返回 f 的平方根。</p><h2 id="Input-输入"><a href="#Input-输入" class="headerlink" title="Input 输入"></a>Input 输入</h2><p>GetKey() ：按键一直按着时触发。<br>GetKeyDown()：按键被按下那一刻进行触发。<br>GetKeyUp() :按键被按下后抬起时触发。</p><p>GetMouseButton(0&#x2F;1&#x2F;2)：1:左键 2:右键 3:中键 鼠标一直按着时触发。<br>GetMouseButtonDown()：鼠标按下那一刻触发。<br>GetMouseButtonUp()：鼠标抬起的那一刻时触发。</p><p>GetButtonDown()：键盘按钮按下那一刻触发。<br>GetButton()：键盘按钮抬起的那一刻时触发。<br>GetButtonUp()：键盘按钮抬起的那一刻时触发。</p><p>GetAxis(“虚拟轴名”)：通过按下的虚拟轴来返回-1~1之间的值，开始值是0，然后向-1&#x2F;1进行渐渐的变化，有一定的加速度。一般用来控制运动的，比如是赛车的加速运动等。<br>GetAxisRaw() ：其他的和GetAxis差不多，就是少了渐变效果，返回值只有 0 1 -1三个。</p><p>anyKeyDown{get;} ：当任何按键被按下（包括鼠标按键）时返回true。<br>anyKey{get;} ：当任何按键被按着（包括鼠标）时返回true。<br>mousePosition{get;} ：返回鼠标在屏幕上的像素坐标，【屏幕坐标】z轴衡为0的。</p><h2 id="Vector2：二维向量"><a href="#Vector2：二维向量" class="headerlink" title="Vector2：二维向量"></a>Vector2：二维向量</h2><p>&#x2F;&#x2F;public Vector2 (float x, float y);<br>magnitude{get;} ：返回向量的长度。<br>normalized{get;} ：返回这个向量长度为1的矢量，不管这个向量多长，也是返回1的矢量，只是返回值，不对原向量的值产生影响。<br>Normalize() ：无参数的，也是向量化，但是调用该方法会改变原向量值，使其的值被向量化 了。<br>ClampMagnitude() ：将一个向量限制在参数中指定的长度之间。<br>MoveToWards() ：用来做匀速的运动，由一个位置向另一个位置进行移动。<br>sqrMagnitude{get;} ： 对求向量的的长度时不进行开平方根运算了，减少性能的损耗，一般是用来比较两个向量的长度大小的。<br> 扩充：向量是结构体，为值类型，修改其中的变量的时候要整体进行修改，不能单独的进行单个变量的赋值修改。</p><h2 id="Vector3：三维变量"><a href="#Vector3：三维变量" class="headerlink" title="Vector3：三维变量"></a>Vector3：三维变量</h2><p>&#x2F;&#x2F;public Vector3 (float x, float y, float z);<br>Cross() ：插乘运算【左手法则】，通过两个向量来获得另一个向量的方向，然后进行相关的判断。<br>Project() ：投影运算。<br>Reflect() ：反射运算。<br>Slerp() ：按照角度进行插值，与lerp的按照位置信息进行插值的，一般用在炮台的旋转，使旋转的更加平滑。<br>Distence(a,b)：返回float a和b之间的距离</p><h2 id="Random随机数类"><a href="#Random随机数类" class="headerlink" title="Random随机数类"></a>Random随机数类</h2><h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><ul><li><code>InitState</code>：通过参数指定的种子随机化生成器的状态，然后再调用Range()产生随机数的时候会依据种子来进行生成，则每一次运行所生成的随机数都是一样的，是伪随机数。一般要生成的随机数不同，可以设置参数System.DataTime.Now.Ticks：通过时间戳来完成。</li><li><code>Range(min,max)</code> ：返回一个 在最小值（包括）和最大值（包括）之间的浮点型随机数（只读）。</li></ul><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><ul><li><code>insideUnitFCircle</code> ：返回一个单位圆内的随机点（只读）。</li><li><code>insideUnitSphere</code> ：返回单位球内的一个随机点（只读）。</li><li><code>onUnitSphere</code>：返回单位球表面上的一个随机点（只读）。</li><li><code>rotation</code> ：返回随机旋转。</li><li><code>rotationUniform</code> ：返回具有一致分布的随机旋转。</li><li><code>state</code> ：获取或设置随机数生成器的完整内部状态。</li><li><code>value</code> ：返回一个在[0.0,1.0]范围内的随机值（只读）。</li></ul><h3 id="System-Random"><a href="#System-Random" class="headerlink" title="System.Random"></a>System.Random</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li><code>Random();</code>&#x2F;&#x2F;使用默认种子值(系统时间的毫秒值)初始化 Random 类的新实例。</li><li><code>Random(Int32);</code>&#x2F;&#x2F;使用指定的种子值初始化 Random 类的新实例。<ul><li>由于Random在不给定随机种子的情况下是使用系统当前时间刻作为随机种子，所以在运行速度较快时，容易生成重复结果，此时可以使用该方法生成不会重复的随机种子： <code>int RandomSeed=BitConverter.ToInt32(Guid.NewGuid().ToByteArray());</code> 。</li></ul></li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><code>Next();</code>&#x2F;&#x2F;每次产生一个不同的随机正整数</li><li><code>Next(int max Value);</code>&#x2F;&#x2F;产生一个比 max Value（2,147,483,647） 小的正整数</li><li><code>Next(int min Value,int max Value);</code>&#x2F;&#x2F;产生一个 minValue~maxValue 的正整数，但不包含 maxValue</li><li><code>NextDouble();</code>&#x2F;&#x2F;产生一个0.0~1.0的浮点数</li><li><code>NextBytes(byte[]);</code>&#x2F;&#x2F;用随机数填充指定字节数的数组（0-255）</li></ul><h2 id="Quaternion-四元数"><a href="#Quaternion-四元数" class="headerlink" title="Quaternion 四元数"></a>Quaternion 四元数</h2><p>欧拉角【eylarAngles】与面板中的值对应和四元数【rotation】之间是可以进行转换的，一般欧拉角是用来让用户可以直观的看到的，而四元数是用来控制内部的运算 的。<br>eulerAngles ：将四元数转变为欧拉角<br>Euler() ：将欧拉角转变为四元数<br>LookRotation() ：让玩家通过设置四元数来进行望向敌人的旋转，将向量方向转变为四元数<br>slerp() ：在做朝向的旋转的时候，不建议使用lerp，而是建议使用slerp,使其的旋转朝向更为平滑，更加的自然</p><h2 id="Rigidbody：刚体组件，控制物体的移动"><a href="#Rigidbody：刚体组件，控制物体的移动" class="headerlink" title="Rigidbody：刚体组件，控制物体的移动"></a>Rigidbody：刚体组件，控制物体的移动</h2><p>[[笔记&#x2F;Unity&#x2F;Unity 移动物体的方式|Unity 移动物体的方式]]里有一些常见的Rigidbody用法<br>AddForce() ：添加到刚体的力。<br>AddExplosionForce() ：应用一个力到刚体来模拟爆炸效果。<br>AddForceAtPosition() ：在position位置应用force力。作为结果这个将在这个物体上应用一个扭矩和力。<br>AddRelativeForce() ：添加力到刚体。相对于它的系统坐标。<br>AddRelativeTorque(vector3) ：相对于它的局部坐标系统添加扭矩到刚体。<br>AddTorque(vector3) ：添加扭矩到刚体。<br>ClosestPointOnBounds() ：指定位置到该刚体附加的碰撞器的最近点。<br>GetPointVelocity() ：刚体在世界坐标空间，worldPoint点的速度。<br>GetRelativePointVelocity() ：相对于刚体在relativePoint点的速度。<br>IsSleeping() ：是否正休眠<br>MovePosition() ：移动位置,对position的优化，其中利用了插值运算，一般持续运动的则使用这个方法，不出现卡顿的现象.<br>MoveRotation() ：移动角度,用来控制刚体的旋转，一般不建议使用rotation,比较耗性能，建议使用MoveRotation(),然后配合Quaternion,slerp()进行使用，使其更加的平滑.<br>ResetCenterOfMass() ：重置刚体的质心。<br>ResetInertiaTensor() ：重置惯性张量值和旋转。<br>Rigidbody.position: 可以通过刚体来控制运动，在控制运动方面，使用rigibody.positon比transform.porition计算要快的多，相关的物理计算也是在刚体中计算好了，但是不建议使用这个方法来持续的控制物体的运动，不平滑，控制一两次的时候还可以使用<br>SetDensity() ：设置基于附加的碰撞器假设一个固定的密度质量。<br>Sleep() ：强制刚体休眠。<br>SweepTest() ：如果一个刚体碰到任何东西触发测试。<br>SweepTestAll() ：就像Rigidbody.SweepTest，当返回的是所有碰撞信息。<br>WakeUp() ：强制一个刚体唤醒。</p><h2 id="Collision-碰撞体"><a href="#Collision-碰撞体" class="headerlink" title="Collision 碰撞体"></a>Collision 碰撞体</h2><p>变量</p><p> articulationBody | The ArticulationBody of the collider that your GameObject collides with (Read Only).<br>body：The Rigidbody or ArticulationBody of the collider that your Component collides with (Read Only).<br>collider：我们撞击的 Collider（只读）。<br>contactCount：获取此碰撞的接触点数。<br>contacts： 物理引擎生成的接触点。应避免使用它，因为它会产生内存垃圾。改用 GetContact 或 GetContacts。<br>gameObject：您正在碰撞其碰撞体的 GameObject。（只读）。<br>impulse：为解析此碰撞而施加于该接触对的总冲量。<br>relativeVelocity：这两个碰撞对象的相对线性速度（只读）。<br>rigidbody：我们撞击的 Rigidbody（只读）。如果我们撞击的对象未附加刚体，则这是 &#x2F;null&#x2F;。<br>transform：我们撞击的对象的 Transform（只读）。</p><p>Collider.OnCollisionEnter : 碰撞体进入碰撞范围<br>Collider.OnCollisionStay : 碰撞体停留<br>Collider.OnCollisionExit : 碰撞体脱离碰撞体</p><h2 id="Camera-相机组件"><a href="#Camera-相机组件" class="headerlink" title="Camera 相机组件"></a>Camera 相机组件</h2><p>Camera是一个设备，玩家通过它看世界。<br>屏幕空间点用像素定义，屏幕的左下为(0,0);右上是（PixelWidth，pixelHeight）.Z的位置是以世界单位衡量的到相机的距离。<br>视口空间点是规范的并相对于相机的。相机的左下为（0,0）；右上是（1,1）；Z的位置是以世界为单位衡量的到相机的距离。<br>Ray ray &#x3D; cameraMain.ScreenPointToRay(Input.mousePosition); &#x2F;&#x2F;获得相机到鼠标之间的射线<br>RaycastHit hit; &#x2F;&#x2F;用来存放射线检测到的游戏物体的信息的<br>bool temp &#x3D; Physics.Raycast(ray, out hit); &#x2F;&#x2F;进行射线检测<br>CalculateObliqueMatrix() ：计算并返回倾斜接近水平的投影矩阵。<br>CopyFrom() ：使这个相机的设置与其他相机相同。<br>Render() ：手动渲染相机。<br>RenderToCubemap() ：从这个相机渲染到一个立方贴图。<br>RenderWithShader() ： 用shader替代渲染相机。<br>ResetAspect() ：恢复长宽比为屏幕的长宽比。<br>ResetProjectionMatrix() ：让投影反映正常的相机参数。<br>ResetReplacementShader() ：从相机上移除shader替换。<br>ResetWorldToCameraMatrix() ：在场景中让渲染位置反映相机的位置<br>ScreenPointToRay() ：返回一条射线从摄像机通过一个屏幕点。<br>ScreenToViewportPoint() ：从屏幕空间到视窗空间的变换位置。<br>ScreenToWorldPoint() ：从屏幕空间到世界空间的变化位置。<br>SetReplacementShader() ：使相机渲染用shader替换。<br>SetTargetBuffers() ：设置相机渲染到一个或多个RenderTextures所选择的缓冲区。<br>ViewportPointToRay() ：返回从相机出发穿过视点的一个射线。<br>ViewportToScreenPoint() ：从视口空间到屏幕空间的变换位置。<br>ViewportToWorldPoint() ：从视窗空间到世界空间的变换位置。<br>WorldToScreenPoint() ：从世界空间到屏幕空间变换位置。<br>WorldToViewportPoint() ：从世界空间到视窗空间的变换位置。</p><h2 id="Application-程序"><a href="#Application-程序" class="headerlink" title="Application 程序"></a>Application 程序</h2><p><code>OpenURL(&quot;www.baidu.com&quot;)</code>  ：打开指定的网址<br>Application.Quit()  ：退出游戏的运行<br>CapturScreenshot(“游戏截图”) ： 用来截图的，字符串为截图fileName<br><code>Application.streamingAssetsPath</code>：这个属性用于返回流数据的缓存目录，返回路径为相对路径，适合设置一些外部数据文件的路径。在Unity工程的Assets目录下起一个名为“StreamingAssets”的文件夹即可，然后用Application.streamingAssetsPath访问，这个文件夹中的资源在打包时会原封不动的打包进去，不会压缩，一般放置一些资源数据。在PC&#x2F;MAC中可实现对文件的“增删改查”等操作，但在移动端是一个只读路径。</p><h2 id="SceneManager-场景类"><a href="#SceneManager-场景类" class="headerlink" title="SceneManager 场景类"></a>SceneManager 场景类</h2><p>LoadScene()  ：加载下一个场景，一般是用在另一个场景不是太大的情况下<br>LoadSceneAsync()  ：异步加载下一个场景，返回AsyncOperation类型，里面包含了加载的信息，加载的进度条等等。可以让用户缓解等待加载场景的时间<br>sceneCount ： 获得当前加载的场景个数<br>sceneCountInBuildSettings  ：在Build面板中加载的场景个数<br>GetActiveScene() ： 获取已经加载的当前场景的信息<br>GetSceneAt(index) ： 加载index索引的场景</p><p>当加载新的场景的时候会触发下面的事件：<br>activeSceneChanged  ：当有新场景被加载的时候就会调用这个事件<br>sceneLoaded  ：当有新场景加载完成的时候就会触发这个事件<br>    &#x2F;&#x2F;事件的注册时通过加方法来进行注册的：<br>SceneManger.activeSceneChanged+&#x3D;OnAcitiveScenenChanged;</p><h2 id="Ray-射线"><a href="#Ray-射线" class="headerlink" title="Ray 射线"></a>Ray 射线</h2><p>&#x2F;&#x2F;一般射线检测要在射线检测的范围内，并且被检测物体要有Collider<br>direction ：射线的方向。<br>origin ：射线的原点。<br>Ray ：创建一条射线从origin开始，沿direction方向。<br>&#x2F;&#x2F;public Ray (Vector3 origin, Vector3 direction);<br>Raycast；检测的是射线碰撞到的第一个物体，不具有穿透性<br>RaycastAll：返回的是RaycastHit数组，具有穿透性，可以返回检测到的多个游戏物体<br>RaycastHit hit; &#x2F;&#x2F;存储射线检测到的游戏物体信息<br>PaycastHit hit;&#x2F;&#x2F;hit中存放的是射线检测的碰撞信息</p><h2 id="WWW-类"><a href="#WWW-类" class="headerlink" title="WWW 类"></a>WWW 类</h2><p>&#x2F;&#x2F;下载 是用来在网络中下载资源的<br>WWW  ：用给定的URL创建一个WWW请求。<br>GetAudioClip()  ：从下载数据，返回一个AudioClip（只读）。<br>LoadImageIntoTexture()  ：利用一个从下载数据中的图像来替换现有Texture2D。<br>LoadUnityWeb()  ：加载新的web播放器数据文件。</p><h2 id="GUI-现已废弃，使用unity自带UI-UGUI"><a href="#GUI-现已废弃，使用unity自带UI-UGUI" class="headerlink" title="GUI &#x2F;&#x2F;现已废弃，使用unity自带UI(UGUI)"></a>GUI &#x2F;&#x2F;现已废弃，使用unity自带UI(UGUI)</h2><p>静态函数<br>BeginGroup：开始一个组。必须与 EndGroup 调用配对使用。&#x2F;&#x2F;public static void BeginGroup (Rect position, string text);<br>EndGroup：结束组。<br>BeginScrollView：在 GUI 内开始一个滚动视图。&#x2F;&#x2F;public static Vector2 BeginScrollView (Rect position, Vector2 scrollPosition, Rect viewRect);<br>EndScrollView：结束使用 BeginScrollView 调用开始的滚动视图。<br>Box在 ：GUI 层上创建一个框。&#x2F;&#x2F;public static void Box (Rect position, string text);<br>BringWindowToBack：将特定窗口放置到该浮动窗口的后方。<br>BringWindowToFront：将特定窗口放置到该浮动窗口的前方。<br>Button：创建一个单击按钮。当用户点击该按钮时，立即执行一些操作。&#x2F;&#x2F;public static bool Button (Rect position, string text);<br>DragWindow：使窗口可被拖动。&#x2F;&#x2F;public static void DragWindow (Rect position);<br>FocusControl：将键盘焦点移动到某个命名控件。<br>FocusWindow：使某个窗口成为激活窗口。<br>HorizontalScrollbar：创建一个水平滚动条。滚动条是用于滚动文档的控件。大多数情况下，您需要的可能是滚动视图。<br>&#x2F;&#x2F;public static float HorizontalScrollbar (Rect position, float value, float size, float leftValue, float rightValue);<br>HorizontalSlider：用户可以拖动的水平滑动条，用于在最小值和最大值之间更改某值。<br>&#x2F;&#x2F;public static float HorizontalSlider (Rect position, float value, float leftValue, float rightValue);<br>Label：在屏幕上创建一个文本或纹理标签。&#x2F;&#x2F;public static void Label (Rect position, string text);<br>ModalWindow：显示一个模态窗口。<br>ScrollTo：滚动包含的所有滚动视图，让它们尝试使 position 可见。&#x2F;&#x2F;public static void ScrollTo (Rect position);<br>SelectionGrid：创建一个按钮网格。&#x2F;&#x2F;public static int SelectionGrid (Rect position, int selected, string[] texts, int xCount);<br>TextArea：创建一个可供用户编辑字符串的多行文本区域。&#x2F;&#x2F;public static string TextArea (Rect position, string text);<br>TextField：创建一个可供用户编辑字符串的单行文本字段。&#x2F;&#x2F;public static string TextField (Rect position, string text);<br>Toggle：创建一个打开&#x2F;关闭的开关按钮。&#x2F;&#x2F;public static bool Toggle (Rect position, bool value, string text);<br>Toolbar：创建一个工具栏。&#x2F;&#x2F;public static int Toolbar (Rect position, int selected, string[] texts);<br>VerticalScrollbar：创建一个垂直滚动条。滚动条是用于滚动文档的控件。大多数情况下，您需要的可能是滚动视图。<br>&#x2F;&#x2F;public static float VerticalScrollbar (Rect position, float value, float size, float topValue, float bottomValue);<br>VerticalSlider：用户可以拖动的垂直滑动条，用于在最小值和最大值之间更改某值。<br>&#x2F;&#x2F;public static float VerticalSlider (Rect position, float value, float topValue, float bottomValue);<br>Window：创建一个弹出窗口。&#x2F;&#x2F;public static Rect Window (int id, Rect clientRect, GUI.WindowFunction func, string text);</p><h2 id="Rect-矩形"><a href="#Rect-矩形" class="headerlink" title="Rect 矩形"></a>Rect 矩形</h2><p>构造矩形。&#x2F;&#x2F;public Rect (float x, float y, float width, float height);<br>通过最小&#x2F;最大坐标值创建矩形。&#x2F;&#x2F;public static Rect MinMaxRect (float xmin, float ymin, float xmax, float ymax);</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>匈牙利记号法</title>
    <link href="/2024/02/24/%E5%8C%88%E7%89%99%E5%88%A9%E8%AE%B0%E5%8F%B7%E6%B3%95/"/>
    <url>/2024/02/24/%E5%8C%88%E7%89%99%E5%88%A9%E8%AE%B0%E5%8F%B7%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>有关项目的全局变量用 <code>g_</code> 开始，类的成员变量用 <code>m_</code> ，局部变量若函数较大可考虑用 <code>l_</code> 说明其是局部变量</p><table><thead><tr><th>前缀</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>a_</td><td>Array</td><td>数组</td></tr><tr><td>b_</td><td>bool(int)</td><td>布尔（整数）</td></tr><tr><td>by_</td><td>Unsigned Char(byte)</td><td>无符号字符（字节）</td></tr><tr><td>c</td><td>char</td><td>字符（字节）</td></tr><tr><td>cb</td><td>Count of Bytes</td><td>字节数</td></tr><tr><td>cr</td><td>Color Reference Value</td><td>颜色（参考）值</td></tr><tr><td>cx</td><td>Count of X(short)</td><td>x的集合（短整数）</td></tr><tr><td>f</td><td>Flags(Usually mutiple bit values)</td><td>标志（一般是多位数的数值）</td></tr><tr><td>fn</td><td>Function</td><td>函数</td></tr><tr><td>g_</td><td>global</td><td>全局</td></tr><tr><td>h</td><td>Handle</td><td>句柄</td></tr><tr><td>i</td><td>Integer</td><td>整数</td></tr><tr><td>l</td><td>long</td><td>长整数</td></tr><tr><td>lp</td><td>Long Pointer</td><td>长指针</td></tr><tr><td><strong>m_</strong></td><td>Data Menber of a Class</td><td><strong>一个类的数据成员</strong></td></tr><tr><td>n</td><td>short Integer</td><td>短整数</td></tr><tr><td>p</td><td>Pointer</td><td>指针</td></tr><tr><td>s</td><td>String</td><td>字符串</td></tr><tr><td>sz</td><td>Zero Terminated String</td><td>以零结束的字符串</td></tr><tr><td>tm</td><td>Text Metric</td><td>文本规则</td></tr><tr><td>u</td><td>Unsigned Integer</td><td>无符号整数</td></tr><tr><td>ul</td><td>Unsigned Long(Ulong)</td><td>无符号长整数</td></tr><tr><td>w</td><td>WORD(Unsigned Short)</td><td>无符号短整数</td></tr><tr><td>x,y</td><td>x,y Coordinates(Short)</td><td>坐标值（短整数）</td></tr><tr><td>v</td><td>Void</td><td>空</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>驼峰命名法</title>
    <link href="/2024/02/24/%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E6%B3%95/"/>
    <url>/2024/02/24/%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>简介：混合使用大小写字母来构成变量和函数的名称。<br>意义：提高代码的可读性，便于项目开发和维护。</p><ul><li>大驼峰法：<ul><li>规则：<strong>第一个单词和其他单词的首字母均大写。</strong></li><li>用于：<em><strong>类名</strong></em>、<em><strong>函数名</strong></em>、<em><strong>属性</strong></em>、<em><strong>命名空间</strong></em>。</li></ul></li><li>小驼峰法：<ul><li>规则：<strong>除第一个单词外，其他单词首字母均大写。</strong></li><li>用于：<em><strong>变量</strong></em>。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Front-matter</title>
    <link href="/2024/02/21/Hexo-Front-matter/"/>
    <url>/2024/02/21/Hexo-Front-matter/</url>
    
    <content type="html"><![CDATA[<h2 id="可用的文章属性"><a href="#可用的文章属性" class="headerlink" title="可用的文章属性"></a>可用的文章属性</h2><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>config.default_layout</td></tr><tr><td>title</td><td>标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>update</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启文章的评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章的永久链接</td><td>null</td></tr><tr><td>excerpt</td><td>纯文本的页面摘要</td><td></td></tr><tr><td>disableNunjucks</td><td>禁用Nunjucks标签 <code>&#123;&#123;&#125;&#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code>和标签插件的渲染功能</td><td>false</td></tr><tr><td>lang</td><td>设置语言以覆盖自动检测</td><td></td></tr><tr><td>published</td><td>文章是否发布</td><td>post下的文章为true，draft下的文章给你为false</td></tr></tbody></table><h2 id="典型的分类和标签形式如下"><a href="#典型的分类和标签形式如下" class="headerlink" title="典型的分类和标签形式如下"></a>典型的分类和标签形式如下</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">diary</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">PS3</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Games</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>死循环</title>
    <link href="/2024/02/21/%E6%AD%BB%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/02/21/%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h1><h2 id="以无限循环的形式实现监听守护"><a href="#以无限循环的形式实现监听守护" class="headerlink" title="以无限循环的形式实现监听守护"></a>以无限循环的形式实现监听守护</h2><p><code>for (; ; )</code> 死循环（Infinite Loop）</p><p>这种写法通常用于需要持续运行或监听某些事件的场景，例如服务器端的消息监听、守护线程的执行等。在使用死循环时，需要谨慎处理循环体内部的逻辑，确保循环能够在适当的时候退出，避免陷入无限循环造成系统资源的浪费或程序无法正常终止。要注意的是，在某些情况下，编译器或代码静态分析工具可能会提示无限循环的警告或错误，因为这种写法可能会引起程序不可达的问题。因此，在使用死循环时，需要确保循环终止的条件是正确设置和处理的。在循环内使用 <code>continue;</code> 和 <code>break;</code> 控制循环条件。类似于 <code>While(true)</code> 。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>判断浮点数是否相等</title>
    <link href="/2024/02/21/%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
    <url>/2024/02/21/%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h1 id="关于浮点数判断时的误差问题"><a href="#关于浮点数判断时的误差问题" class="headerlink" title="关于浮点数判断时的误差问题"></a>关于浮点数判断时的误差问题</h1><p>在做关于浮点数的计算时，不要使用 <code>==</code> 来做判断，因为无法避免误差。</p><p>不要使用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> testresult:<span class="hljs-built_in">float</span> = <span class="hljs-number">1</span> - <span class="hljs-number">0.8f</span>;<br><span class="hljs-keyword">if</span>(testresult == <span class="hljs-number">0.2f</span>)<br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;equal&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;not equal&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>而是：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">WithinErroeMargin</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> left, <span class="hljs-built_in">float</span> right</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> Mathf.Abs.(f: left = right) &lt;= <span class="hljs-number">0.0001f</span>;<span class="hljs-comment">//误差范围0.0001f，根据使用场景而定</span><br>&#125;<br><span class="hljs-keyword">if</span>(WithinErrorMargin(left: testresult, right: <span class="hljs-number">0.2f</span>))<br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;WithinErrorMargin equal&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;WithinErrorMargin not equal&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当需要浮点数转换时，尽量避免强制转换产生的精度丢失，常用的库有：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">bool</span> equal = Mathf.Approximately(<span class="hljs-number">1.0f</span>, <span class="hljs-number">10.0f</span> / <span class="hljs-number">10.0f</span>);<br><span class="hljs-comment">//该判断的误差范围接近无穷小</span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Mathf.RoundToInt(f:<span class="hljs-number">1.9f</span>);<span class="hljs-comment">//2 返回最接近1.9的整数 四舍五入 </span><br>Mathf.FloorToInt(f:<span class="hljs-number">1.9f</span>);<span class="hljs-comment">//1 返回小于等于1.9的最大整数 向下取整</span><br>Mathf.CeliToInt(f:<span class="hljs-number">1.9f</span>);<span class="hljs-comment">//2 返回大于等于1.9的最小整数 向上取整</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高内聚低耦合</title>
    <link href="/2024/02/21/%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    <url>/2024/02/21/%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h1><h2 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h2><p>高内聚是另外一个评判软件设计质量的标准。内聚更为专业的说法叫做功能内聚，是对系统中元素职责的相关性和集中度的量度。如果元素有高度的相关职责，除了这些职责在没有其他的工作，那么该元素就有高内聚。<br>内聚指的是模块内部的功能，最强的就是功能不能拆分，也就是原子化。</p><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><p>这就好像，如果我是一个项目经理，我的职责是监控和协调我的项目各个阶段的工作。当我的项目进入需求分析阶段，我会请求需求分析员来完成；当我的项目进入开发阶段，我会请求软件开发人员来完成；当我的项目需要测试的时候，我会请求测试人员。。。。。。如果我参与了开发，我就不是一个高内聚的元素，因为开发不是我的职责。</p><h3 id="为什么要高内聚"><a href="#为什么要高内聚" class="headerlink" title="为什么要高内聚"></a>为什么要高内聚</h3><ul><li>可读性</li><li>复用性</li><li>可维护性和易变更性</li></ul><h2 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h2><p>耦合就是元素与元素之间的连接，感知和依赖量度。这里说的元素即是功能，对象，系统，子系统。模块。</p><h3 id="例如-1"><a href="#例如-1" class="headerlink" title="例如"></a>例如</h3><p>现在有方法A和方法B<br>我们在A元素去调用B元素，当B元素有问题或者不存在的时候，A元素就不能正常的工作，那么就说元素A和元素B耦合</p><h3 id="耦合带来的问题"><a href="#耦合带来的问题" class="headerlink" title="耦合带来的问题"></a>耦合带来的问题</h3><p>当元素B变更或者不存在时，都将影响元素A的正常运作，影响系统的可维护性和易变更性。同时元素A只能运行在元素B中，这也大大的降低了A元素的可复用性。正因为耦合的种种弊端，我们才需要在软件设计上追求低耦合</p><h3 id="如何实现低耦合"><a href="#如何实现低耦合" class="headerlink" title="如何实现低耦合"></a>如何实现低耦合</h3><ul><li>元素A不能过度依赖元素B</li><li>合理的职责划分：让系统中的对象各司其职，不仅是提高内聚的要求，同时也可以有效地降低耦合</li><li>使用接口而不是继承：我们不难发现。继承就是一种耦合，假如子类A继承了父类B，不论是直接继承或者间接继承，一但父类B不存在或者发生任何变更，都将导致子类A不得不修改或者重写。假如父类B的子类数十上百的，这就是灾难性的变更。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>建站纪念</title>
    <link href="/2024/02/21/%E5%BB%BA%E7%AB%99%E7%BA%AA%E5%BF%B5/"/>
    <url>/2024/02/21/%E5%BB%BA%E7%AB%99%E7%BA%AA%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="建站纪念"><a href="#建站纪念" class="headerlink" title="建站纪念"></a>建站纪念</h1><p>从昨天的半夜一置到凌晨5点，折腾了半天终于用hexo把hithub个人主页给弄出来了。<br>之前用github默认的jekyll模板建过主页，导致hexo建站push不上去，git成功但是主页没变。<br>之后直接删库，重新建了一个username.github.io，又重新push了一次，这次成功了，而且也不用像jekyll那样，DeployAction之后还得等几分钟。<br>只要hexo generate之后hexo deploy上去就更新完成了。确实是非常方便，而且我用了fluid主题，文档非常丰富，之后肯定还会继续更新和丰富博客。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/21/hello-world/"/>
    <url>/2024/02/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-创建新post"><a href="#Create-a-new-post-创建新post" class="headerlink" title="Create a new post 创建新post"></a>Create a new post 创建新post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server-运行服务"><a href="#Run-server-运行服务" class="headerlink" title="Run server 运行服务"></a>Run server 运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files-生成固定文档"><a href="#Generate-static-files-生成固定文档" class="headerlink" title="Generate static files 生成固定文档"></a>Generate static files 生成固定文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites-部署到远程站点"><a href="#Deploy-to-remote-sites-部署到远程站点" class="headerlink" title="Deploy to remote sites 部署到远程站点"></a>Deploy to remote sites 部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
