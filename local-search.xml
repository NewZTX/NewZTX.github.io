<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>死循环</title>
    <link href="/2024/02/21/%E6%AD%BB%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/02/21/%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h1><h2 id="以无限循环的形式实现监听守护"><a href="#以无限循环的形式实现监听守护" class="headerlink" title="以无限循环的形式实现监听守护"></a>以无限循环的形式实现监听守护</h2><p><code>for (; ; )</code> 死循环（Infinite Loop）</p><p>这种写法通常用于需要持续运行或监听某些事件的场景，例如服务器端的消息监听、守护线程的执行等。在使用死循环时，需要谨慎处理循环体内部的逻辑，确保循环能够在适当的时候退出，避免陷入无限循环造成系统资源的浪费或程序无法正常终止。要注意的是，在某些情况下，编译器或代码静态分析工具可能会提示无限循环的警告或错误，因为这种写法可能会引起程序不可达的问题。因此，在使用死循环时，需要确保循环终止的条件是正确设置和处理的。在循环内使用 <code>continue;</code> 和 <code>break;</code> 控制循环条件。类似于 <code>While(true)</code> 。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>判断浮点数是否相等</title>
    <link href="/2024/02/21/%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
    <url>/2024/02/21/%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h1 id="关于浮点数判断时的误差问题"><a href="#关于浮点数判断时的误差问题" class="headerlink" title="关于浮点数判断时的误差问题"></a>关于浮点数判断时的误差问题</h1><p>在做关于浮点数的计算时，不要使用 <code>==</code> 来做判断，因为无法避免误差。</p><p>不要使用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> testresult:<span class="hljs-built_in">float</span> = <span class="hljs-number">1</span> - <span class="hljs-number">0.8f</span>;<br><span class="hljs-keyword">if</span>(testresult == <span class="hljs-number">0.2f</span>)<br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;equal&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;not equal&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>而是：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">WithinErroeMargin</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> left, <span class="hljs-built_in">float</span> right</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> Mathf.Abs.(f: left = right) &lt;= <span class="hljs-number">0.0001f</span>;<span class="hljs-comment">//误差范围0.0001f，根据使用场景而定</span><br>&#125;<br><span class="hljs-keyword">if</span>(WithinErrorMargin(left: testresult, right: <span class="hljs-number">0.2f</span>))<br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;WithinErrorMargin equal&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Debug.Log(message:<span class="hljs-string">&quot;WithinErrorMargin not equal&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当需要浮点数转换时，尽量避免强制转换产生的精度丢失，常用的库有：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">bool</span> equal = Mathf.Approximately(<span class="hljs-number">1.0f</span>, <span class="hljs-number">10.0f</span> / <span class="hljs-number">10.0f</span>);<br><span class="hljs-comment">//该判断的误差范围接近无穷小</span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Mathf.RoundToInt(f:<span class="hljs-number">1.9f</span>);<span class="hljs-comment">//2 返回最接近1.9的整数 四舍五入 </span><br>Mathf.FloorToInt(f:<span class="hljs-number">1.9f</span>);<span class="hljs-comment">//1 返回小于等于1.9的最大整数 向下取整</span><br>Mathf.CeliToInt(f:<span class="hljs-number">1.9f</span>);<span class="hljs-comment">//2 返回大于等于1.9的最小整数 向上取整</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高内聚低耦合</title>
    <link href="/2024/02/21/%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    <url>/2024/02/21/%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h1><h2 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h2><p>高内聚是另外一个评判软件设计质量的标准。内聚更为专业的说法叫做功能内聚，是对系统中元素职责的相关性和集中度的量度。如果元素有高度的相关职责，除了这些职责在没有其他的工作，那么该元素就有高内聚。<br>内聚指的是模块内部的功能，最强的就是功能不能拆分，也就是原子化。</p><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><p>这就好像，如果我是一个项目经理，我的职责是监控和协调我的项目各个阶段的工作。当我的项目进入需求分析阶段，我会请求需求分析员来完成；当我的项目进入开发阶段，我会请求软件开发人员来完成；当我的项目需要测试的时候，我会请求测试人员。。。。。。如果我参与了开发，我就不是一个高内聚的元素，因为开发不是我的职责。</p><h3 id="为什么要高内聚"><a href="#为什么要高内聚" class="headerlink" title="为什么要高内聚"></a>为什么要高内聚</h3><ul><li>可读性</li><li>复用性</li><li>可维护性和易变更性</li></ul><h2 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h2><p>耦合就是元素与元素之间的连接，感知和依赖量度。这里说的元素即是功能，对象，系统，子系统。模块。</p><h3 id="例如-1"><a href="#例如-1" class="headerlink" title="例如"></a>例如</h3><p>现在有方法A和方法B<br>我们在A元素去调用B元素，当B元素有问题或者不存在的时候，A元素就不能正常的工作，那么就说元素A和元素B耦合</p><h3 id="耦合带来的问题"><a href="#耦合带来的问题" class="headerlink" title="耦合带来的问题"></a>耦合带来的问题</h3><p>当元素B变更或者不存在时，都将影响元素A的正常运作，影响系统的可维护性和易变更性。同时元素A只能运行在元素B中，这也大大的降低了A元素的可复用性。正因为耦合的种种弊端，我们才需要在软件设计上追求低耦合</p><h3 id="如何实现低耦合"><a href="#如何实现低耦合" class="headerlink" title="如何实现低耦合"></a>如何实现低耦合</h3><ul><li>元素A不能过度依赖元素B</li><li>合理的职责划分：让系统中的对象各司其职，不仅是提高内聚的要求，同时也可以有效地降低耦合</li><li>使用接口而不是继承：我们不难发现。继承就是一种耦合，假如子类A继承了父类B，不论是直接继承或者间接继承，一但父类B不存在或者发生任何变更，都将导致子类A不得不修改或者重写。假如父类B的子类数十上百的，这就是灾难性的变更。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>建站纪念</title>
    <link href="/2024/02/21/%E5%BB%BA%E7%AB%99%E7%BA%AA%E5%BF%B5/"/>
    <url>/2024/02/21/%E5%BB%BA%E7%AB%99%E7%BA%AA%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="建站纪念"><a href="#建站纪念" class="headerlink" title="建站纪念"></a>建站纪念</h1><p>从昨天的半夜一置到凌晨5点，折腾了半天终于用hexo把hithub个人主页给弄出来了。<br>之前用github默认的jekyll模板建过主页，导致hexo建站push不上去，git成功但是主页没变。<br>之后直接删库，重新建了一个username.github.io，又重新push了一次，这次成功了，而且也不用像jekyll那样，DeployAction之后还得等几分钟。<br>只要hexo generate之后hexo deploy上去就更新完成了。确实是非常方便，而且我用了fluid主题，文档非常丰富，之后肯定还会继续更新和丰富博客。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/21/hello-world/"/>
    <url>/2024/02/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-创建新post"><a href="#Create-a-new-post-创建新post" class="headerlink" title="Create a new post 创建新post"></a>Create a new post 创建新post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server-运行服务"><a href="#Run-server-运行服务" class="headerlink" title="Run server 运行服务"></a>Run server 运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files-生成固定文档"><a href="#Generate-static-files-生成固定文档" class="headerlink" title="Generate static files 生成固定文档"></a>Generate static files 生成固定文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites-部署到远程站点"><a href="#Deploy-to-remote-sites-部署到远程站点" class="headerlink" title="Deploy to remote sites 部署到远程站点"></a>Deploy to remote sites 部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
